/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Rengo
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  HTTPValidationError
} from '../schemas/hTTPValidationError'
import type {
  TableData
} from '../schemas/tableData'
import type {
  TenantRecordReadData
} from '../schemas/tenantRecordReadData'
import type {
  UserRecordCreateData
} from '../schemas/userRecordCreateData'
import type {
  UserRecordReadData
} from '../schemas/userRecordReadData'
import type {
  UserRecordUpdateData
} from '../schemas/userRecordUpdateData'
import type {
  UserTenantRelationshipRecordCreateData
} from '../schemas/userTenantRelationshipRecordCreateData'
import type {
  UserTenantRelationshipRecordReadData
} from '../schemas/userTenantRelationshipRecordReadData'
import { axiosRequest } from '../../shared/api/api';



/**
 * @summary Create Endpoint
 */
export const userCreate = (
    userRecordCreateData: UserRecordCreateData,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<UserRecordReadData>(
      {url: `/api/users/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userRecordCreateData, signal
    },
      );
    }
  


export const getUserCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userCreate>>, TError,{data: UserRecordCreateData}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userCreate>>, TError,{data: UserRecordCreateData}, TContext> => {
    
const mutationKey = ['userCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userCreate>>, {data: UserRecordCreateData}> = (props) => {
          const {data} = props ?? {};

          return  userCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserCreateMutationResult = NonNullable<Awaited<ReturnType<typeof userCreate>>>
    export type UserCreateMutationBody = UserRecordCreateData
    export type UserCreateMutationError = HTTPValidationError

    /**
 * @summary Create Endpoint
 */
export const useUserCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userCreate>>, TError,{data: UserRecordCreateData}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof userCreate>>,
        TError,
        {data: UserRecordCreateData},
        TContext
      > => {

      const mutationOptions = getUserCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Delete Many Endpoint
 */
export const usersDelete = (
    usersDeleteBody: string[],
 ) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/users/bulk`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: usersDeleteBody
    },
      );
    }
  


export const getUsersDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDelete>>, TError,{data: string[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersDelete>>, TError,{data: string[]}, TContext> => {
    
const mutationKey = ['usersDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDelete>>, {data: string[]}> = (props) => {
          const {data} = props ?? {};

          return  usersDelete(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof usersDelete>>>
    export type UsersDeleteMutationBody = string[]
    export type UsersDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Many Endpoint
 */
export const useUsersDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDelete>>, TError,{data: string[]}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof usersDelete>>,
        TError,
        {data: string[]},
        TContext
      > => {

      const mutationOptions = getUsersDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Create Many Endpoint
 */
export const usersBulkCreate = (
    userRecordCreateData: UserRecordCreateData[],
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<UserRecordReadData[]>(
      {url: `/api/users/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userRecordCreateData, signal
    },
      );
    }
  


export const getUsersBulkCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersBulkCreate>>, TError,{data: UserRecordCreateData[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersBulkCreate>>, TError,{data: UserRecordCreateData[]}, TContext> => {
    
const mutationKey = ['usersBulkCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersBulkCreate>>, {data: UserRecordCreateData[]}> = (props) => {
          const {data} = props ?? {};

          return  usersBulkCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersBulkCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersBulkCreate>>>
    export type UsersBulkCreateMutationBody = UserRecordCreateData[]
    export type UsersBulkCreateMutationError = HTTPValidationError

    /**
 * @summary Create Many Endpoint
 */
export const useUsersBulkCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersBulkCreate>>, TError,{data: UserRecordCreateData[]}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof usersBulkCreate>>,
        TError,
        {data: UserRecordCreateData[]},
        TContext
      > => {

      const mutationOptions = getUsersBulkCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Current User Api
 */
export const currentUserRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<UserRecordReadData>(
      {url: `/api/users/current-user`, method: 'GET', signal
    },
      );
    }
  

export const getCurrentUserRetrieveQueryKey = () => {
    return [`/api/users/current-user`] as const;
    }

    
export const getCurrentUserRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCurrentUserRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUserRetrieve>>> = ({ signal }) => currentUserRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CurrentUserRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof currentUserRetrieve>>>
export type CurrentUserRetrieveQueryError = unknown


export function useCurrentUserRetrieve<TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUserRetrieve>>,
          TError,
          Awaited<ReturnType<typeof currentUserRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserRetrieve<TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUserRetrieve>>,
          TError,
          Awaited<ReturnType<typeof currentUserRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserRetrieve<TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User Api
 */

export function useCurrentUserRetrieve<TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCurrentUserRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCurrentUserRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCurrentUserRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUserRetrieve>>> = ({ signal }) => currentUserRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CurrentUserRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof currentUserRetrieve>>>
export type CurrentUserRetrieveSuspenseQueryError = unknown


export function useCurrentUserRetrieveSuspense<TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserRetrieveSuspense<TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserRetrieveSuspense<TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User Api
 */

export function useCurrentUserRetrieveSuspense<TData = Awaited<ReturnType<typeof currentUserRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCurrentUserRetrieveSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Current User Tenants Api
 */
export const currentUserTenantsRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TenantRecordReadData[]>(
      {url: `/api/users/current-user-tenants`, method: 'GET', signal
    },
      );
    }
  

export const getCurrentUserTenantsRetrieveQueryKey = () => {
    return [`/api/users/current-user-tenants`] as const;
    }

    
export const getCurrentUserTenantsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCurrentUserTenantsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>> = ({ signal }) => currentUserTenantsRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CurrentUserTenantsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>>
export type CurrentUserTenantsRetrieveQueryError = unknown


export function useCurrentUserTenantsRetrieve<TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUserTenantsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof currentUserTenantsRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserTenantsRetrieve<TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUserTenantsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof currentUserTenantsRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserTenantsRetrieve<TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User Tenants Api
 */

export function useCurrentUserTenantsRetrieve<TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCurrentUserTenantsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCurrentUserTenantsRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCurrentUserTenantsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>> = ({ signal }) => currentUserTenantsRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CurrentUserTenantsRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>>
export type CurrentUserTenantsRetrieveSuspenseQueryError = unknown


export function useCurrentUserTenantsRetrieveSuspense<TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserTenantsRetrieveSuspense<TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCurrentUserTenantsRetrieveSuspense<TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Current User Tenants Api
 */

export function useCurrentUserTenantsRetrieveSuspense<TData = Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof currentUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCurrentUserTenantsRetrieveSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Internal Get User By Email Api
 */
export const internalUserByEmailRetrieve = (
    email: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<UserRecordReadData>(
      {url: `/api/users/internal/user-by-email/${email}`, method: 'POST', signal
    },
      );
    }
  


export const getInternalUserByEmailRetrieveMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof internalUserByEmailRetrieve>>, TError,{email: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof internalUserByEmailRetrieve>>, TError,{email: string}, TContext> => {
    
const mutationKey = ['internalUserByEmailRetrieve'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof internalUserByEmailRetrieve>>, {email: string}> = (props) => {
          const {email} = props ?? {};

          return  internalUserByEmailRetrieve(email,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InternalUserByEmailRetrieveMutationResult = NonNullable<Awaited<ReturnType<typeof internalUserByEmailRetrieve>>>
    
    export type InternalUserByEmailRetrieveMutationError = HTTPValidationError

    /**
 * @summary Internal Get User By Email Api
 */
export const useInternalUserByEmailRetrieve = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof internalUserByEmailRetrieve>>, TError,{email: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof internalUserByEmailRetrieve>>,
        TError,
        {email: string},
        TContext
      > => {

      const mutationOptions = getInternalUserByEmailRetrieveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Internal Get User Api
 */
export const internalUserRetrieve = (
    userId: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<UserRecordReadData>(
      {url: `/api/users/internal/user/${userId}`, method: 'GET', signal
    },
      );
    }
  

export const getInternalUserRetrieveQueryKey = (userId: string,) => {
    return [`/api/users/internal/user/${userId}`] as const;
    }

    
export const getInternalUserRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInternalUserRetrieveQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof internalUserRetrieve>>> = ({ signal }) => internalUserRetrieve(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InternalUserRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof internalUserRetrieve>>>
export type InternalUserRetrieveQueryError = HTTPValidationError


export function useInternalUserRetrieve<TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof internalUserRetrieve>>,
          TError,
          Awaited<ReturnType<typeof internalUserRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInternalUserRetrieve<TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof internalUserRetrieve>>,
          TError,
          Awaited<ReturnType<typeof internalUserRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInternalUserRetrieve<TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Internal Get User Api
 */

export function useInternalUserRetrieve<TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInternalUserRetrieveQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getInternalUserRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInternalUserRetrieveQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof internalUserRetrieve>>> = ({ signal }) => internalUserRetrieve(userId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InternalUserRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof internalUserRetrieve>>>
export type InternalUserRetrieveSuspenseQueryError = HTTPValidationError


export function useInternalUserRetrieveSuspense<TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInternalUserRetrieveSuspense<TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInternalUserRetrieveSuspense<TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Internal Get User Api
 */

export function useInternalUserRetrieveSuspense<TData = Awaited<ReturnType<typeof internalUserRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInternalUserRetrieveSuspenseQueryOptions(userId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Internal Get User Tenants Api
 */
export const internalUserTenantsRetrieve = (
    userId: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TenantRecordReadData[]>(
      {url: `/api/users/internal/user/${userId}/tenants`, method: 'GET', signal
    },
      );
    }
  

export const getInternalUserTenantsRetrieveQueryKey = (userId: string,) => {
    return [`/api/users/internal/user/${userId}/tenants`] as const;
    }

    
export const getInternalUserTenantsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInternalUserTenantsRetrieveQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>> = ({ signal }) => internalUserTenantsRetrieve(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InternalUserTenantsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>>
export type InternalUserTenantsRetrieveQueryError = HTTPValidationError


export function useInternalUserTenantsRetrieve<TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof internalUserTenantsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof internalUserTenantsRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInternalUserTenantsRetrieve<TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof internalUserTenantsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof internalUserTenantsRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInternalUserTenantsRetrieve<TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Internal Get User Tenants Api
 */

export function useInternalUserTenantsRetrieve<TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInternalUserTenantsRetrieveQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getInternalUserTenantsRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInternalUserTenantsRetrieveQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>> = ({ signal }) => internalUserTenantsRetrieve(userId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InternalUserTenantsRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>>
export type InternalUserTenantsRetrieveSuspenseQueryError = HTTPValidationError


export function useInternalUserTenantsRetrieveSuspense<TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInternalUserTenantsRetrieveSuspense<TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInternalUserTenantsRetrieveSuspense<TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Internal Get User Tenants Api
 */

export function useInternalUserTenantsRetrieveSuspense<TData = Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof internalUserTenantsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInternalUserTenantsRetrieveSuspenseQueryOptions(userId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create User Tenant Relationship Api
 */
export const userTenantRelationshipCreate = (
    userTenantRelationshipRecordCreateData: UserTenantRelationshipRecordCreateData,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<UserTenantRelationshipRecordReadData>(
      {url: `/api/users/user-tenant-relationship`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userTenantRelationshipRecordCreateData, signal
    },
      );
    }
  


export const getUserTenantRelationshipCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userTenantRelationshipCreate>>, TError,{data: UserTenantRelationshipRecordCreateData}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userTenantRelationshipCreate>>, TError,{data: UserTenantRelationshipRecordCreateData}, TContext> => {
    
const mutationKey = ['userTenantRelationshipCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userTenantRelationshipCreate>>, {data: UserTenantRelationshipRecordCreateData}> = (props) => {
          const {data} = props ?? {};

          return  userTenantRelationshipCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserTenantRelationshipCreateMutationResult = NonNullable<Awaited<ReturnType<typeof userTenantRelationshipCreate>>>
    export type UserTenantRelationshipCreateMutationBody = UserTenantRelationshipRecordCreateData
    export type UserTenantRelationshipCreateMutationError = HTTPValidationError

    /**
 * @summary Create User Tenant Relationship Api
 */
export const useUserTenantRelationshipCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userTenantRelationshipCreate>>, TError,{data: UserTenantRelationshipRecordCreateData}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof userTenantRelationshipCreate>>,
        TError,
        {data: UserTenantRelationshipRecordCreateData},
        TContext
      > => {

      const mutationOptions = getUserTenantRelationshipCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Bulk Create User Tenant Relationships Api
 */
export const userTenantRelationshipsBulkCreate = (
    userTenantRelationshipRecordCreateData: UserTenantRelationshipRecordCreateData[],
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<UserTenantRelationshipRecordReadData[]>(
      {url: `/api/users/user-tenant-relationship/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userTenantRelationshipRecordCreateData, signal
    },
      );
    }
  


export const getUserTenantRelationshipsBulkCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userTenantRelationshipsBulkCreate>>, TError,{data: UserTenantRelationshipRecordCreateData[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userTenantRelationshipsBulkCreate>>, TError,{data: UserTenantRelationshipRecordCreateData[]}, TContext> => {
    
const mutationKey = ['userTenantRelationshipsBulkCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userTenantRelationshipsBulkCreate>>, {data: UserTenantRelationshipRecordCreateData[]}> = (props) => {
          const {data} = props ?? {};

          return  userTenantRelationshipsBulkCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserTenantRelationshipsBulkCreateMutationResult = NonNullable<Awaited<ReturnType<typeof userTenantRelationshipsBulkCreate>>>
    export type UserTenantRelationshipsBulkCreateMutationBody = UserTenantRelationshipRecordCreateData[]
    export type UserTenantRelationshipsBulkCreateMutationError = HTTPValidationError

    /**
 * @summary Bulk Create User Tenant Relationships Api
 */
export const useUserTenantRelationshipsBulkCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userTenantRelationshipsBulkCreate>>, TError,{data: UserTenantRelationshipRecordCreateData[]}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof userTenantRelationshipsBulkCreate>>,
        TError,
        {data: UserTenantRelationshipRecordCreateData[]},
        TContext
      > => {

      const mutationOptions = getUserTenantRelationshipsBulkCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get User Tenants Table Api
 */
export const userTenantsTableDataRetrieve = (
    userId: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TableData>(
      {url: `/api/users/user/${userId}/tenants`, method: 'GET', signal
    },
      );
    }
  

export const getUserTenantsTableDataRetrieveQueryKey = (userId: string,) => {
    return [`/api/users/user/${userId}/tenants`] as const;
    }

    
export const getUserTenantsTableDataRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserTenantsTableDataRetrieveQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>> = ({ signal }) => userTenantsTableDataRetrieve(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserTenantsTableDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>>
export type UserTenantsTableDataRetrieveQueryError = HTTPValidationError


export function useUserTenantsTableDataRetrieve<TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserTenantsTableDataRetrieve<TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserTenantsTableDataRetrieve<TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User Tenants Table Api
 */

export function useUserTenantsTableDataRetrieve<TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserTenantsTableDataRetrieveQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUserTenantsTableDataRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserTenantsTableDataRetrieveQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>> = ({ signal }) => userTenantsTableDataRetrieve(userId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserTenantsTableDataRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>>
export type UserTenantsTableDataRetrieveSuspenseQueryError = HTTPValidationError


export function useUserTenantsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserTenantsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserTenantsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User Tenants Table Api
 */

export function useUserTenantsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userTenantsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserTenantsTableDataRetrieveSuspenseQueryOptions(userId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Users Table Data Api
 */
export const usersTableDataRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TableData>(
      {url: `/api/users/users-table-data`, method: 'GET', signal
    },
      );
    }
  

export const getUsersTableDataRetrieveQueryKey = () => {
    return [`/api/users/users-table-data`] as const;
    }

    
export const getUsersTableDataRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersTableDataRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersTableDataRetrieve>>> = ({ signal }) => usersTableDataRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersTableDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof usersTableDataRetrieve>>>
export type UsersTableDataRetrieveQueryError = unknown


export function useUsersTableDataRetrieve<TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof usersTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersTableDataRetrieve<TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof usersTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersTableDataRetrieve<TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Users Table Data Api
 */

export function useUsersTableDataRetrieve<TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersTableDataRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUsersTableDataRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersTableDataRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersTableDataRetrieve>>> = ({ signal }) => usersTableDataRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersTableDataRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof usersTableDataRetrieve>>>
export type UsersTableDataRetrieveSuspenseQueryError = unknown


export function useUsersTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Users Table Data Api
 */

export function useUsersTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof usersTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersTableDataRetrieveSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Delete Endpoint
 */
export const userDelete = (
    id: string,
 ) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/users/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getUserDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['userDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  userDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof userDelete>>>
    
    export type UserDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Endpoint
 */
export const useUserDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userDelete>>, TError,{id: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof userDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getUserDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Endpoint
 */
export const userRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<UserRecordReadData>(
      {url: `/api/users/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getUserRetrieveQueryKey = (id: string,) => {
    return [`/api/users/${id}`] as const;
    }

    
export const getUserRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userRetrieve>>> = ({ signal }) => userRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof userRetrieve>>>
export type UserRetrieveQueryError = HTTPValidationError


export function useUserRetrieve<TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userRetrieve>>,
          TError,
          Awaited<ReturnType<typeof userRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserRetrieve<TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userRetrieve>>,
          TError,
          Awaited<ReturnType<typeof userRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserRetrieve<TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Endpoint
 */

export function useUserRetrieve<TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUserRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userRetrieve>>> = ({ signal }) => userRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof userRetrieve>>>
export type UserRetrieveSuspenseQueryError = HTTPValidationError


export function useUserRetrieveSuspense<TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserRetrieveSuspense<TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserRetrieveSuspense<TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Endpoint
 */

export function useUserRetrieveSuspense<TData = Awaited<ReturnType<typeof userRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof userRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserRetrieveSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Endpoint
 */
export const userUpdate = (
    id: string,
    userRecordUpdateData: UserRecordUpdateData,
 ) => {
      
      
      return axiosRequest<UserRecordReadData>(
      {url: `/api/users/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: userRecordUpdateData
    },
      );
    }
  


export const getUserUpdateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUpdate>>, TError,{id: string;data: UserRecordUpdateData}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof userUpdate>>, TError,{id: string;data: UserRecordUpdateData}, TContext> => {
    
const mutationKey = ['userUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userUpdate>>, {id: string;data: UserRecordUpdateData}> = (props) => {
          const {id,data} = props ?? {};

          return  userUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof userUpdate>>>
    export type UserUpdateMutationBody = UserRecordUpdateData
    export type UserUpdateMutationError = HTTPValidationError

    /**
 * @summary Update Endpoint
 */
export const useUserUpdate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUpdate>>, TError,{id: string;data: UserRecordUpdateData}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof userUpdate>>,
        TError,
        {id: string;data: UserRecordUpdateData},
        TContext
      > => {

      const mutationOptions = getUserUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    