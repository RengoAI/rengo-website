/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Rengo
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  HTTPValidationError
} from '../schemas/hTTPValidationError'
import type {
  PersonRecordCreateData
} from '../schemas/personRecordCreateData'
import type {
  PersonRecordReadData
} from '../schemas/personRecordReadData'
import type {
  PersonRecordUpdateData
} from '../schemas/personRecordUpdateData'
import type {
  TableData
} from '../schemas/tableData'
import type {
  VersionReadDataPersonRecordReadData
} from '../schemas/versionReadDataPersonRecordReadData'
import { axiosRequest } from '../../shared/api/api';



/**
 * @summary Create Endpoint
 */
export const personCreate = (
    personRecordCreateData: PersonRecordCreateData,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<PersonRecordReadData>(
      {url: `/api/people/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: personRecordCreateData, signal
    },
      );
    }
  


export const getPersonCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personCreate>>, TError,{data: PersonRecordCreateData}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof personCreate>>, TError,{data: PersonRecordCreateData}, TContext> => {
    
const mutationKey = ['personCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof personCreate>>, {data: PersonRecordCreateData}> = (props) => {
          const {data} = props ?? {};

          return  personCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PersonCreateMutationResult = NonNullable<Awaited<ReturnType<typeof personCreate>>>
    export type PersonCreateMutationBody = PersonRecordCreateData
    export type PersonCreateMutationError = HTTPValidationError

    /**
 * @summary Create Endpoint
 */
export const usePersonCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personCreate>>, TError,{data: PersonRecordCreateData}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof personCreate>>,
        TError,
        {data: PersonRecordCreateData},
        TContext
      > => {

      const mutationOptions = getPersonCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Delete Many Endpoint
 */
export const peopleDelete = (
    peopleDeleteBody: string[],
 ) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/people/bulk`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: peopleDeleteBody
    },
      );
    }
  


export const getPeopleDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof peopleDelete>>, TError,{data: string[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof peopleDelete>>, TError,{data: string[]}, TContext> => {
    
const mutationKey = ['peopleDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof peopleDelete>>, {data: string[]}> = (props) => {
          const {data} = props ?? {};

          return  peopleDelete(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PeopleDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof peopleDelete>>>
    export type PeopleDeleteMutationBody = string[]
    export type PeopleDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Many Endpoint
 */
export const usePeopleDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof peopleDelete>>, TError,{data: string[]}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof peopleDelete>>,
        TError,
        {data: string[]},
        TContext
      > => {

      const mutationOptions = getPeopleDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Create Many Endpoint
 */
export const peopleBulkCreate = (
    personRecordCreateData: PersonRecordCreateData[],
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<PersonRecordReadData[]>(
      {url: `/api/people/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: personRecordCreateData, signal
    },
      );
    }
  


export const getPeopleBulkCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof peopleBulkCreate>>, TError,{data: PersonRecordCreateData[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof peopleBulkCreate>>, TError,{data: PersonRecordCreateData[]}, TContext> => {
    
const mutationKey = ['peopleBulkCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof peopleBulkCreate>>, {data: PersonRecordCreateData[]}> = (props) => {
          const {data} = props ?? {};

          return  peopleBulkCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PeopleBulkCreateMutationResult = NonNullable<Awaited<ReturnType<typeof peopleBulkCreate>>>
    export type PeopleBulkCreateMutationBody = PersonRecordCreateData[]
    export type PeopleBulkCreateMutationError = HTTPValidationError

    /**
 * @summary Create Many Endpoint
 */
export const usePeopleBulkCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof peopleBulkCreate>>, TError,{data: PersonRecordCreateData[]}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof peopleBulkCreate>>,
        TError,
        {data: PersonRecordCreateData[]},
        TContext
      > => {

      const mutationOptions = getPeopleBulkCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Person Data Table Api
 */
export const peopleTableDataRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TableData>(
      {url: `/api/people/person-table-data`, method: 'GET', signal
    },
      );
    }
  

export const getPeopleTableDataRetrieveQueryKey = () => {
    return [`/api/people/person-table-data`] as const;
    }

    
export const getPeopleTableDataRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPeopleTableDataRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof peopleTableDataRetrieve>>> = ({ signal }) => peopleTableDataRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PeopleTableDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof peopleTableDataRetrieve>>>
export type PeopleTableDataRetrieveQueryError = unknown


export function usePeopleTableDataRetrieve<TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof peopleTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof peopleTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePeopleTableDataRetrieve<TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof peopleTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof peopleTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePeopleTableDataRetrieve<TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Person Data Table Api
 */

export function usePeopleTableDataRetrieve<TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPeopleTableDataRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getPeopleTableDataRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPeopleTableDataRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof peopleTableDataRetrieve>>> = ({ signal }) => peopleTableDataRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PeopleTableDataRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof peopleTableDataRetrieve>>>
export type PeopleTableDataRetrieveSuspenseQueryError = unknown


export function usePeopleTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePeopleTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePeopleTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Person Data Table Api
 */

export function usePeopleTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof peopleTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPeopleTableDataRetrieveSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Delete Endpoint
 */
export const personDelete = (
    id: string,
 ) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/people/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getPersonDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof personDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['personDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof personDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  personDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PersonDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof personDelete>>>
    
    export type PersonDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Endpoint
 */
export const usePersonDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personDelete>>, TError,{id: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof personDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getPersonDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Endpoint
 */
export const personRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<PersonRecordReadData>(
      {url: `/api/people/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getPersonRetrieveQueryKey = (id: string,) => {
    return [`/api/people/${id}`] as const;
    }

    
export const getPersonRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPersonRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof personRetrieve>>> = ({ signal }) => personRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PersonRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof personRetrieve>>>
export type PersonRetrieveQueryError = HTTPValidationError


export function usePersonRetrieve<TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof personRetrieve>>,
          TError,
          Awaited<ReturnType<typeof personRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonRetrieve<TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof personRetrieve>>,
          TError,
          Awaited<ReturnType<typeof personRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonRetrieve<TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Endpoint
 */

export function usePersonRetrieve<TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPersonRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getPersonRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPersonRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof personRetrieve>>> = ({ signal }) => personRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PersonRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof personRetrieve>>>
export type PersonRetrieveSuspenseQueryError = HTTPValidationError


export function usePersonRetrieveSuspense<TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonRetrieveSuspense<TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonRetrieveSuspense<TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Endpoint
 */

export function usePersonRetrieveSuspense<TData = Awaited<ReturnType<typeof personRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPersonRetrieveSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Endpoint
 */
export const personUpdate = (
    id: string,
    personRecordUpdateData: PersonRecordUpdateData,
 ) => {
      
      
      return axiosRequest<PersonRecordReadData>(
      {url: `/api/people/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: personRecordUpdateData
    },
      );
    }
  


export const getPersonUpdateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personUpdate>>, TError,{id: string;data: PersonRecordUpdateData}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof personUpdate>>, TError,{id: string;data: PersonRecordUpdateData}, TContext> => {
    
const mutationKey = ['personUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof personUpdate>>, {id: string;data: PersonRecordUpdateData}> = (props) => {
          const {id,data} = props ?? {};

          return  personUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PersonUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof personUpdate>>>
    export type PersonUpdateMutationBody = PersonRecordUpdateData
    export type PersonUpdateMutationError = HTTPValidationError

    /**
 * @summary Update Endpoint
 */
export const usePersonUpdate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof personUpdate>>, TError,{id: string;data: PersonRecordUpdateData}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof personUpdate>>,
        TError,
        {id: string;data: PersonRecordUpdateData},
        TContext
      > => {

      const mutationOptions = getPersonUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Versions Endpoint
 */
export const personVersionsRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<VersionReadDataPersonRecordReadData[]>(
      {url: `/api/people/${id}/versions`, method: 'GET', signal
    },
      );
    }
  

export const getPersonVersionsRetrieveQueryKey = (id: string,) => {
    return [`/api/people/${id}/versions`] as const;
    }

    
export const getPersonVersionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPersonVersionsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof personVersionsRetrieve>>> = ({ signal }) => personVersionsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PersonVersionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof personVersionsRetrieve>>>
export type PersonVersionsRetrieveQueryError = HTTPValidationError


export function usePersonVersionsRetrieve<TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof personVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof personVersionsRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonVersionsRetrieve<TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof personVersionsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof personVersionsRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonVersionsRetrieve<TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Versions Endpoint
 */

export function usePersonVersionsRetrieve<TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPersonVersionsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getPersonVersionsRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPersonVersionsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof personVersionsRetrieve>>> = ({ signal }) => personVersionsRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PersonVersionsRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof personVersionsRetrieve>>>
export type PersonVersionsRetrieveSuspenseQueryError = HTTPValidationError


export function usePersonVersionsRetrieveSuspense<TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonVersionsRetrieveSuspense<TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePersonVersionsRetrieveSuspense<TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Versions Endpoint
 */

export function usePersonVersionsRetrieveSuspense<TData = Awaited<ReturnType<typeof personVersionsRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof personVersionsRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPersonVersionsRetrieveSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



