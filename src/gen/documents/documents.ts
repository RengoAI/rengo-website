/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Rengo
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  DocumentPresignedReadData
} from '../schemas/documentPresignedReadData'
import type {
  DocumentRecordCreateData
} from '../schemas/documentRecordCreateData'
import type {
  DocumentRecordUpdateData
} from '../schemas/documentRecordUpdateData'
import type {
  HTTPValidationError
} from '../schemas/hTTPValidationError'
import type {
  TableData
} from '../schemas/tableData'
import { axiosRequest } from '../../shared/api/api';



/**
 * @summary Create Endpoint
 */
export const documentCreate = (
    documentRecordCreateData: DocumentRecordCreateData,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<DocumentPresignedReadData>(
      {url: `/api/documents/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentRecordCreateData, signal
    },
      );
    }
  


export const getDocumentCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentCreate>>, TError,{data: DocumentRecordCreateData}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof documentCreate>>, TError,{data: DocumentRecordCreateData}, TContext> => {
    
const mutationKey = ['documentCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentCreate>>, {data: DocumentRecordCreateData}> = (props) => {
          const {data} = props ?? {};

          return  documentCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof documentCreate>>>
    export type DocumentCreateMutationBody = DocumentRecordCreateData
    export type DocumentCreateMutationError = HTTPValidationError

    /**
 * @summary Create Endpoint
 */
export const useDocumentCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentCreate>>, TError,{data: DocumentRecordCreateData}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof documentCreate>>,
        TError,
        {data: DocumentRecordCreateData},
        TContext
      > => {

      const mutationOptions = getDocumentCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Delete Many Endpoint
 */
export const documentsDelete = (
    documentsDeleteBody: string[],
 ) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/documents/bulk`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: documentsDeleteBody
    },
      );
    }
  


export const getDocumentsDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsDelete>>, TError,{data: string[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof documentsDelete>>, TError,{data: string[]}, TContext> => {
    
const mutationKey = ['documentsDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentsDelete>>, {data: string[]}> = (props) => {
          const {data} = props ?? {};

          return  documentsDelete(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof documentsDelete>>>
    export type DocumentsDeleteMutationBody = string[]
    export type DocumentsDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Many Endpoint
 */
export const useDocumentsDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsDelete>>, TError,{data: string[]}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof documentsDelete>>,
        TError,
        {data: string[]},
        TContext
      > => {

      const mutationOptions = getDocumentsDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Create Many Endpoint
 */
export const documentsCreateBulk = (
    documentRecordCreateData: DocumentRecordCreateData[],
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<DocumentPresignedReadData[]>(
      {url: `/api/documents/bulk`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentRecordCreateData, signal
    },
      );
    }
  


export const getDocumentsCreateBulkMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsCreateBulk>>, TError,{data: DocumentRecordCreateData[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof documentsCreateBulk>>, TError,{data: DocumentRecordCreateData[]}, TContext> => {
    
const mutationKey = ['documentsCreateBulk'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentsCreateBulk>>, {data: DocumentRecordCreateData[]}> = (props) => {
          const {data} = props ?? {};

          return  documentsCreateBulk(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentsCreateBulkMutationResult = NonNullable<Awaited<ReturnType<typeof documentsCreateBulk>>>
    export type DocumentsCreateBulkMutationBody = DocumentRecordCreateData[]
    export type DocumentsCreateBulkMutationError = HTTPValidationError

    /**
 * @summary Create Many Endpoint
 */
export const useDocumentsCreateBulk = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsCreateBulk>>, TError,{data: DocumentRecordCreateData[]}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof documentsCreateBulk>>,
        TError,
        {data: DocumentRecordCreateData[]},
        TContext
      > => {

      const mutationOptions = getDocumentsCreateBulkMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Generate an Excel template for bulk model creation by model name
 * @summary Generate Excel Template Api
 */
export const excelTemplateGenerate = (
    modelName: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<Blob>(
      {url: `/api/documents/excel-template/${modelName}`, method: 'GET',
        responseType: 'blob', signal
    },
      );
    }
  

export const getExcelTemplateGenerateQueryKey = (modelName: string,) => {
    return [`/api/documents/excel-template/${modelName}`] as const;
    }

    
export const getExcelTemplateGenerateQueryOptions = <TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(modelName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExcelTemplateGenerateQueryKey(modelName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof excelTemplateGenerate>>> = ({ signal }) => excelTemplateGenerate(modelName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(modelName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExcelTemplateGenerateQueryResult = NonNullable<Awaited<ReturnType<typeof excelTemplateGenerate>>>
export type ExcelTemplateGenerateQueryError = HTTPValidationError


export function useExcelTemplateGenerate<TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(
 modelName: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof excelTemplateGenerate>>,
          TError,
          Awaited<ReturnType<typeof excelTemplateGenerate>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExcelTemplateGenerate<TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(
 modelName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof excelTemplateGenerate>>,
          TError,
          Awaited<ReturnType<typeof excelTemplateGenerate>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExcelTemplateGenerate<TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(
 modelName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Generate Excel Template Api
 */

export function useExcelTemplateGenerate<TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(
 modelName: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExcelTemplateGenerateQueryOptions(modelName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getExcelTemplateGenerateSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(modelName: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExcelTemplateGenerateQueryKey(modelName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof excelTemplateGenerate>>> = ({ signal }) => excelTemplateGenerate(modelName, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExcelTemplateGenerateSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof excelTemplateGenerate>>>
export type ExcelTemplateGenerateSuspenseQueryError = HTTPValidationError


export function useExcelTemplateGenerateSuspense<TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(
 modelName: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExcelTemplateGenerateSuspense<TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(
 modelName: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExcelTemplateGenerateSuspense<TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(
 modelName: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Generate Excel Template Api
 */

export function useExcelTemplateGenerateSuspense<TData = Awaited<ReturnType<typeof excelTemplateGenerate>>, TError = HTTPValidationError>(
 modelName: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof excelTemplateGenerate>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExcelTemplateGenerateSuspenseQueryOptions(modelName,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Document Data Table Api
 */
export const documentsTableDataRetrieve = (
    linkedRecordId: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TableData>(
      {url: `/api/documents/linked-record/${linkedRecordId}/document-table-data`, method: 'GET', signal
    },
      );
    }
  

export const getDocumentsTableDataRetrieveQueryKey = (linkedRecordId: string,) => {
    return [`/api/documents/linked-record/${linkedRecordId}/document-table-data`] as const;
    }

    
export const getDocumentsTableDataRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(linkedRecordId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDocumentsTableDataRetrieveQueryKey(linkedRecordId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof documentsTableDataRetrieve>>> = ({ signal }) => documentsTableDataRetrieve(linkedRecordId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(linkedRecordId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DocumentsTableDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof documentsTableDataRetrieve>>>
export type DocumentsTableDataRetrieveQueryError = HTTPValidationError


export function useDocumentsTableDataRetrieve<TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(
 linkedRecordId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof documentsTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof documentsTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDocumentsTableDataRetrieve<TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(
 linkedRecordId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof documentsTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof documentsTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDocumentsTableDataRetrieve<TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(
 linkedRecordId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Document Data Table Api
 */

export function useDocumentsTableDataRetrieve<TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(
 linkedRecordId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDocumentsTableDataRetrieveQueryOptions(linkedRecordId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getDocumentsTableDataRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(linkedRecordId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDocumentsTableDataRetrieveQueryKey(linkedRecordId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof documentsTableDataRetrieve>>> = ({ signal }) => documentsTableDataRetrieve(linkedRecordId, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DocumentsTableDataRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof documentsTableDataRetrieve>>>
export type DocumentsTableDataRetrieveSuspenseQueryError = HTTPValidationError


export function useDocumentsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(
 linkedRecordId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDocumentsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(
 linkedRecordId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDocumentsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(
 linkedRecordId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Document Data Table Api
 */

export function useDocumentsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError = HTTPValidationError>(
 linkedRecordId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDocumentsTableDataRetrieveSuspenseQueryOptions(linkedRecordId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Download Documents Zip Api
 */
export const documentsZipDownload = (
    linkedRecordId: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<Blob>(
      {url: `/api/documents/linked-record/${linkedRecordId}/download-zip`, method: 'POST',
        responseType: 'blob', signal
    },
      );
    }
  


export const getDocumentsZipDownloadMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsZipDownload>>, TError,{linkedRecordId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof documentsZipDownload>>, TError,{linkedRecordId: string}, TContext> => {
    
const mutationKey = ['documentsZipDownload'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentsZipDownload>>, {linkedRecordId: string}> = (props) => {
          const {linkedRecordId} = props ?? {};

          return  documentsZipDownload(linkedRecordId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentsZipDownloadMutationResult = NonNullable<Awaited<ReturnType<typeof documentsZipDownload>>>
    
    export type DocumentsZipDownloadMutationError = HTTPValidationError

    /**
 * @summary Download Documents Zip Api
 */
export const useDocumentsZipDownload = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentsZipDownload>>, TError,{linkedRecordId: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof documentsZipDownload>>,
        TError,
        {linkedRecordId: string},
        TContext
      > => {

      const mutationOptions = getDocumentsZipDownloadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Delete Endpoint
 */
export const documentDelete = (
    id: string,
 ) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/documents/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDocumentDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentDelete>>, TError,{id: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof documentDelete>>, TError,{id: string}, TContext> => {
    
const mutationKey = ['documentDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  documentDelete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof documentDelete>>>
    
    export type DocumentDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Endpoint
 */
export const useDocumentDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentDelete>>, TError,{id: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof documentDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDocumentDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Endpoint
 */
export const documentRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<DocumentPresignedReadData>(
      {url: `/api/documents/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getDocumentRetrieveQueryKey = (id: string,) => {
    return [`/api/documents/${id}`] as const;
    }

    
export const getDocumentRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDocumentRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof documentRetrieve>>> = ({ signal }) => documentRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DocumentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof documentRetrieve>>>
export type DocumentRetrieveQueryError = HTTPValidationError


export function useDocumentRetrieve<TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof documentRetrieve>>,
          TError,
          Awaited<ReturnType<typeof documentRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDocumentRetrieve<TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof documentRetrieve>>,
          TError,
          Awaited<ReturnType<typeof documentRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDocumentRetrieve<TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Endpoint
 */

export function useDocumentRetrieve<TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDocumentRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getDocumentRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDocumentRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof documentRetrieve>>> = ({ signal }) => documentRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DocumentRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof documentRetrieve>>>
export type DocumentRetrieveSuspenseQueryError = HTTPValidationError


export function useDocumentRetrieveSuspense<TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDocumentRetrieveSuspense<TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDocumentRetrieveSuspense<TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Endpoint
 */

export function useDocumentRetrieveSuspense<TData = Awaited<ReturnType<typeof documentRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof documentRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDocumentRetrieveSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Endpoint
 */
export const documentUpdate = (
    id: string,
    documentRecordUpdateData: DocumentRecordUpdateData,
 ) => {
      
      
      return axiosRequest<DocumentPresignedReadData>(
      {url: `/api/documents/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: documentRecordUpdateData
    },
      );
    }
  


export const getDocumentUpdateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentUpdate>>, TError,{id: string;data: DocumentRecordUpdateData}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof documentUpdate>>, TError,{id: string;data: DocumentRecordUpdateData}, TContext> => {
    
const mutationKey = ['documentUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof documentUpdate>>, {id: string;data: DocumentRecordUpdateData}> = (props) => {
          const {id,data} = props ?? {};

          return  documentUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DocumentUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof documentUpdate>>>
    export type DocumentUpdateMutationBody = DocumentRecordUpdateData
    export type DocumentUpdateMutationError = HTTPValidationError

    /**
 * @summary Update Endpoint
 */
export const useDocumentUpdate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof documentUpdate>>, TError,{id: string;data: DocumentRecordUpdateData}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof documentUpdate>>,
        TError,
        {id: string;data: DocumentRecordUpdateData},
        TContext
      > => {

      const mutationOptions = getDocumentUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    