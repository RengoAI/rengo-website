/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Rengo
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  APIEventRecordReadData
} from '../schemas/aPIEventRecordReadData'
import type {
  BaseModelReadData
} from '../schemas/baseModelReadData'
import type {
  BodyEventBulkCreateFromExcel
} from '../schemas/bodyEventBulkCreateFromExcel'
import type {
  EventBulkCreateFromExcelParams
} from '../schemas/eventBulkCreateFromExcelParams'
import type {
  EventBulkCreateParams
} from '../schemas/eventBulkCreateParams'
import type {
  EventBulkDeleteParams
} from '../schemas/eventBulkDeleteParams'
import type {
  EventCreateParams
} from '../schemas/eventCreateParams'
import type {
  EventDeleteParams
} from '../schemas/eventDeleteParams'
import type {
  ExcelTemplateForBulkCreateGenerateParams
} from '../schemas/excelTemplateForBulkCreateGenerateParams'
import type {
  HTTPValidationError
} from '../schemas/hTTPValidationError'
import type {
  ObjectVersionsTimelineRetrieveParams
} from '../schemas/objectVersionsTimelineRetrieveParams'
import type {
  RawEventBulkCreateAPIData
} from '../schemas/rawEventBulkCreateAPIData'
import type {
  RawEventCreateAPIData
} from '../schemas/rawEventCreateAPIData'
import type {
  TableData
} from '../schemas/tableData'
import type {
  TenantModelEventRecordReadData
} from '../schemas/tenantModelEventRecordReadData'
import type {
  TimelineData
} from '../schemas/timelineData'
import { axiosRequest } from '../../shared/api/api';



/**
 * @summary Get Api Event Api
 */
export const apiEventRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<APIEventRecordReadData>(
      {url: `/api/events/api-event/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getApiEventRetrieveQueryKey = (id: string,) => {
    return [`/api/events/api-event/${id}`] as const;
    }

    
export const getApiEventRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEventRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEventRetrieve>>> = ({ signal }) => apiEventRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiEventRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiEventRetrieve>>>
export type ApiEventRetrieveQueryError = HTTPValidationError


export function useApiEventRetrieve<TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEventRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiEventRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiEventRetrieve<TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiEventRetrieve>>,
          TError,
          Awaited<ReturnType<typeof apiEventRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiEventRetrieve<TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Api Event Api
 */

export function useApiEventRetrieve<TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiEventRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getApiEventRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEventRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEventRetrieve>>> = ({ signal }) => apiEventRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiEventRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof apiEventRetrieve>>>
export type ApiEventRetrieveSuspenseQueryError = HTTPValidationError


export function useApiEventRetrieveSuspense<TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiEventRetrieveSuspense<TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiEventRetrieveSuspense<TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Api Event Api
 */

export function useApiEventRetrieveSuspense<TData = Awaited<ReturnType<typeof apiEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof apiEventRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiEventRetrieveSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Event Timeline
 */
export const eventTimelineRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TimelineData>(
      {url: `/api/events/api-event/${id}/timeline`, method: 'GET', signal
    },
      );
    }
  

export const getEventTimelineRetrieveQueryKey = (id: string,) => {
    return [`/api/events/api-event/${id}/timeline`] as const;
    }

    
export const getEventTimelineRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventTimelineRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventTimelineRetrieve>>> = ({ signal }) => eventTimelineRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EventTimelineRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof eventTimelineRetrieve>>>
export type EventTimelineRetrieveQueryError = HTTPValidationError


export function useEventTimelineRetrieve<TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eventTimelineRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventTimelineRetrieve<TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eventTimelineRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventTimelineRetrieve<TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Event Timeline
 */

export function useEventTimelineRetrieve<TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventTimelineRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEventTimelineRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventTimelineRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventTimelineRetrieve>>> = ({ signal }) => eventTimelineRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EventTimelineRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof eventTimelineRetrieve>>>
export type EventTimelineRetrieveSuspenseQueryError = HTTPValidationError


export function useEventTimelineRetrieveSuspense<TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventTimelineRetrieveSuspense<TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventTimelineRetrieveSuspense<TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Event Timeline
 */

export function useEventTimelineRetrieveSuspense<TData = Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventTimelineRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventTimelineRetrieveSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Bulk Create Event Api
 */
export const eventBulkCreate = (
    rawEventBulkCreateAPIData: RawEventBulkCreateAPIData,
    params: EventBulkCreateParams,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<unknown[]>(
      {url: `/api/events/bulk-create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rawEventBulkCreateAPIData,
        params, signal
    },
      );
    }
  


export const getEventBulkCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBulkCreate>>, TError,{data: RawEventBulkCreateAPIData;params: EventBulkCreateParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof eventBulkCreate>>, TError,{data: RawEventBulkCreateAPIData;params: EventBulkCreateParams}, TContext> => {
    
const mutationKey = ['eventBulkCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventBulkCreate>>, {data: RawEventBulkCreateAPIData;params: EventBulkCreateParams}> = (props) => {
          const {data,params} = props ?? {};

          return  eventBulkCreate(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EventBulkCreateMutationResult = NonNullable<Awaited<ReturnType<typeof eventBulkCreate>>>
    export type EventBulkCreateMutationBody = RawEventBulkCreateAPIData
    export type EventBulkCreateMutationError = HTTPValidationError

    /**
 * @summary Bulk Create Event Api
 */
export const useEventBulkCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBulkCreate>>, TError,{data: RawEventBulkCreateAPIData;params: EventBulkCreateParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof eventBulkCreate>>,
        TError,
        {data: RawEventBulkCreateAPIData;params: EventBulkCreateParams},
        TContext
      > => {

      const mutationOptions = getEventBulkCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Upload an Excel file and create multiple records based on the operation_id.
The Excel file should have column headers matching the field names of the target model.
Only .xlsx files are supported.
 * @summary Bulk Create From Excel Api
 */
export const eventBulkCreateFromExcel = (
    bodyEventBulkCreateFromExcel: BodyEventBulkCreateFromExcel,
    params: EventBulkCreateFromExcelParams,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append('file', bodyEventBulkCreateFromExcel.file)

      return axiosRequest<BaseModelReadData[]>(
      {url: `/api/events/bulk-create-from-excel`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      );
    }
  


export const getEventBulkCreateFromExcelMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBulkCreateFromExcel>>, TError,{data: BodyEventBulkCreateFromExcel;params: EventBulkCreateFromExcelParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof eventBulkCreateFromExcel>>, TError,{data: BodyEventBulkCreateFromExcel;params: EventBulkCreateFromExcelParams}, TContext> => {
    
const mutationKey = ['eventBulkCreateFromExcel'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventBulkCreateFromExcel>>, {data: BodyEventBulkCreateFromExcel;params: EventBulkCreateFromExcelParams}> = (props) => {
          const {data,params} = props ?? {};

          return  eventBulkCreateFromExcel(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EventBulkCreateFromExcelMutationResult = NonNullable<Awaited<ReturnType<typeof eventBulkCreateFromExcel>>>
    export type EventBulkCreateFromExcelMutationBody = BodyEventBulkCreateFromExcel
    export type EventBulkCreateFromExcelMutationError = HTTPValidationError

    /**
 * @summary Bulk Create From Excel Api
 */
export const useEventBulkCreateFromExcel = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBulkCreateFromExcel>>, TError,{data: BodyEventBulkCreateFromExcel;params: EventBulkCreateFromExcelParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof eventBulkCreateFromExcel>>,
        TError,
        {data: BodyEventBulkCreateFromExcel;params: EventBulkCreateFromExcelParams},
        TContext
      > => {

      const mutationOptions = getEventBulkCreateFromExcelMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Bulk Delete Event Api
 */
export const eventBulkDelete = (
    eventBulkDeleteBody: string[],
    params: EventBulkDeleteParams,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/events/bulk-delete`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eventBulkDeleteBody,
        params, signal
    },
      );
    }
  


export const getEventBulkDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBulkDelete>>, TError,{data: string[];params: EventBulkDeleteParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof eventBulkDelete>>, TError,{data: string[];params: EventBulkDeleteParams}, TContext> => {
    
const mutationKey = ['eventBulkDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventBulkDelete>>, {data: string[];params: EventBulkDeleteParams}> = (props) => {
          const {data,params} = props ?? {};

          return  eventBulkDelete(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EventBulkDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventBulkDelete>>>
    export type EventBulkDeleteMutationBody = string[]
    export type EventBulkDeleteMutationError = HTTPValidationError

    /**
 * @summary Bulk Delete Event Api
 */
export const useEventBulkDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventBulkDelete>>, TError,{data: string[];params: EventBulkDeleteParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof eventBulkDelete>>,
        TError,
        {data: string[];params: EventBulkDeleteParams},
        TContext
      > => {

      const mutationOptions = getEventBulkDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Create Event Api
 */
export const eventCreate = (
    rawEventCreateAPIData: RawEventCreateAPIData,
    params: EventCreateParams,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/events/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rawEventCreateAPIData,
        params, signal
    },
      );
    }
  


export const getEventCreateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventCreate>>, TError,{data: RawEventCreateAPIData;params: EventCreateParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof eventCreate>>, TError,{data: RawEventCreateAPIData;params: EventCreateParams}, TContext> => {
    
const mutationKey = ['eventCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventCreate>>, {data: RawEventCreateAPIData;params: EventCreateParams}> = (props) => {
          const {data,params} = props ?? {};

          return  eventCreate(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EventCreateMutationResult = NonNullable<Awaited<ReturnType<typeof eventCreate>>>
    export type EventCreateMutationBody = RawEventCreateAPIData
    export type EventCreateMutationError = HTTPValidationError

    /**
 * @summary Create Event Api
 */
export const useEventCreate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventCreate>>, TError,{data: RawEventCreateAPIData;params: EventCreateParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof eventCreate>>,
        TError,
        {data: RawEventCreateAPIData;params: EventCreateParams},
        TContext
      > => {

      const mutationOptions = getEventCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Delete Event Api
 */
export const eventDelete = (
    params: EventDeleteParams,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<unknown>(
      {url: `/api/events/delete`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getEventDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventDelete>>, TError,{params: EventDeleteParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof eventDelete>>, TError,{params: EventDeleteParams}, TContext> => {
    
const mutationKey = ['eventDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventDelete>>, {params: EventDeleteParams}> = (props) => {
          const {params} = props ?? {};

          return  eventDelete(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EventDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof eventDelete>>>
    
    export type EventDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Event Api
 */
export const useEventDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventDelete>>, TError,{params: EventDeleteParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof eventDelete>>,
        TError,
        {params: EventDeleteParams},
        TContext
      > => {

      const mutationOptions = getEventDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Generate an Excel template for bulk create events based on the operation_id.
For CREATE_DATA_STORE_RECORD operations, provide data_store_table_id to generate a template based on the table schema.
The template includes field descriptions, requirements, and examples.
 * @summary Generate Excel Template Api
 */
export const excelTemplateForBulkCreateGenerate = (
    params: ExcelTemplateForBulkCreateGenerateParams,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<Blob>(
      {url: `/api/events/excel-template`, method: 'POST',
        params,
        responseType: 'blob', signal
    },
      );
    }
  


export const getExcelTemplateForBulkCreateGenerateMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof excelTemplateForBulkCreateGenerate>>, TError,{params: ExcelTemplateForBulkCreateGenerateParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof excelTemplateForBulkCreateGenerate>>, TError,{params: ExcelTemplateForBulkCreateGenerateParams}, TContext> => {
    
const mutationKey = ['excelTemplateForBulkCreateGenerate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof excelTemplateForBulkCreateGenerate>>, {params: ExcelTemplateForBulkCreateGenerateParams}> = (props) => {
          const {params} = props ?? {};

          return  excelTemplateForBulkCreateGenerate(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExcelTemplateForBulkCreateGenerateMutationResult = NonNullable<Awaited<ReturnType<typeof excelTemplateForBulkCreateGenerate>>>
    
    export type ExcelTemplateForBulkCreateGenerateMutationError = HTTPValidationError

    /**
 * @summary Generate Excel Template Api
 */
export const useExcelTemplateForBulkCreateGenerate = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof excelTemplateForBulkCreateGenerate>>, TError,{params: ExcelTemplateForBulkCreateGenerateParams}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof excelTemplateForBulkCreateGenerate>>,
        TError,
        {params: ExcelTemplateForBulkCreateGenerateParams},
        TContext
      > => {

      const mutationOptions = getExcelTemplateForBulkCreateGenerateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get Events Table Data Api
 */
export const eventsTableDataRetrieve = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TableData>(
      {url: `/api/events/history-table-data`, method: 'GET', signal
    },
      );
    }
  

export const getEventsTableDataRetrieveQueryKey = () => {
    return [`/api/events/history-table-data`] as const;
    }

    
export const getEventsTableDataRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventsTableDataRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsTableDataRetrieve>>> = ({ signal }) => eventsTableDataRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EventsTableDataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof eventsTableDataRetrieve>>>
export type EventsTableDataRetrieveQueryError = unknown


export function useEventsTableDataRetrieve<TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eventsTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventsTableDataRetrieve<TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsTableDataRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eventsTableDataRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventsTableDataRetrieve<TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Events Table Data Api
 */

export function useEventsTableDataRetrieve<TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventsTableDataRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEventsTableDataRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEventsTableDataRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsTableDataRetrieve>>> = ({ signal }) => eventsTableDataRetrieve(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EventsTableDataRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof eventsTableDataRetrieve>>>
export type EventsTableDataRetrieveSuspenseQueryError = unknown


export function useEventsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEventsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Events Table Data Api
 */

export function useEventsTableDataRetrieveSuspense<TData = Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof eventsTableDataRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventsTableDataRetrieveSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Object Versions Timeline
 */
export const objectVersionsTimelineRetrieve = (
    id: string,
    params: ObjectVersionsTimelineRetrieveParams,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TimelineData>(
      {url: `/api/events/object/${id}/versions/timeline`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getObjectVersionsTimelineRetrieveQueryKey = (id: string,
    params: ObjectVersionsTimelineRetrieveParams,) => {
    return [`/api/events/object/${id}/versions/timeline`, ...(params ? [params]: [])] as const;
    }

    
export const getObjectVersionsTimelineRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(id: string,
    params: ObjectVersionsTimelineRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getObjectVersionsTimelineRetrieveQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>> = ({ signal }) => objectVersionsTimelineRetrieve(id,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ObjectVersionsTimelineRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>>
export type ObjectVersionsTimelineRetrieveQueryError = HTTPValidationError


export function useObjectVersionsTimelineRetrieve<TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string,
    params: ObjectVersionsTimelineRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectVersionsTimelineRetrieve<TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string,
    params: ObjectVersionsTimelineRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>,
          TError,
          Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectVersionsTimelineRetrieve<TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string,
    params: ObjectVersionsTimelineRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Object Versions Timeline
 */

export function useObjectVersionsTimelineRetrieve<TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string,
    params: ObjectVersionsTimelineRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getObjectVersionsTimelineRetrieveQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getObjectVersionsTimelineRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(id: string,
    params: ObjectVersionsTimelineRetrieveParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getObjectVersionsTimelineRetrieveQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>> = ({ signal }) => objectVersionsTimelineRetrieve(id,params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ObjectVersionsTimelineRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>>
export type ObjectVersionsTimelineRetrieveSuspenseQueryError = HTTPValidationError


export function useObjectVersionsTimelineRetrieveSuspense<TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string,
    params: ObjectVersionsTimelineRetrieveParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectVersionsTimelineRetrieveSuspense<TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string,
    params: ObjectVersionsTimelineRetrieveParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useObjectVersionsTimelineRetrieveSuspense<TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string,
    params: ObjectVersionsTimelineRetrieveParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Object Versions Timeline
 */

export function useObjectVersionsTimelineRetrieveSuspense<TData = Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError = HTTPValidationError>(
 id: string,
    params: ObjectVersionsTimelineRetrieveParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof objectVersionsTimelineRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getObjectVersionsTimelineRetrieveSuspenseQueryOptions(id,params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get tenant model events with optional filtering.
 * @summary Get Tenant Model Event Api
 */
export const tenantModelEventRetrieve = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosRequest<TenantModelEventRecordReadData>(
      {url: `/api/events/tenant-model-event/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getTenantModelEventRetrieveQueryKey = (id: string,) => {
    return [`/api/events/tenant-model-event/${id}`] as const;
    }

    
export const getTenantModelEventRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTenantModelEventRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tenantModelEventRetrieve>>> = ({ signal }) => tenantModelEventRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TenantModelEventRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof tenantModelEventRetrieve>>>
export type TenantModelEventRetrieveQueryError = HTTPValidationError


export function useTenantModelEventRetrieve<TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tenantModelEventRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tenantModelEventRetrieve>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTenantModelEventRetrieve<TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tenantModelEventRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tenantModelEventRetrieve>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTenantModelEventRetrieve<TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Tenant Model Event Api
 */

export function useTenantModelEventRetrieve<TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTenantModelEventRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getTenantModelEventRetrieveSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTenantModelEventRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tenantModelEventRetrieve>>> = ({ signal }) => tenantModelEventRetrieve(id, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TenantModelEventRetrieveSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof tenantModelEventRetrieve>>>
export type TenantModelEventRetrieveSuspenseQueryError = HTTPValidationError


export function useTenantModelEventRetrieveSuspense<TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTenantModelEventRetrieveSuspense<TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTenantModelEventRetrieveSuspense<TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Tenant Model Event Api
 */

export function useTenantModelEventRetrieveSuspense<TData = Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError = HTTPValidationError>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof tenantModelEventRetrieve>>, TError, TData>>, }

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTenantModelEventRetrieveSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



