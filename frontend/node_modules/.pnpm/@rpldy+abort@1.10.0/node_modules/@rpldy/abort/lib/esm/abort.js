import { FILE_STATES, logger } from "@rpldy/shared";
import { fastAbortAll, fastAbortBatch } from "./fastAbort";
const abortNonUploadingItem = (item, aborts, finalizeItem) => {
  logger.debugLog(`abort: aborting ${item.state} item  - `, item);
  finalizeItem(item.id, {
    status: 0,
    state: FILE_STATES.ABORTED,
    response: "aborted"
  });
  return true;
};
const ITEM_STATE_ABORTS = {
  [FILE_STATES.UPLOADING]: (item, aborts) => {
    logger.debugLog(`abort: aborting uploading item  - `, item);
    return aborts[item.id]();
  },
  [FILE_STATES.ADDED]: abortNonUploadingItem,
  [FILE_STATES.PENDING]: abortNonUploadingItem
};
const callAbortOnItem = (item, aborts, finalizeItem) => {
  const itemState = item?.state;
  const method = !!itemState && ITEM_STATE_ABORTS[itemState];
  return method ? method(item, aborts, finalizeItem) : false;
};
const abortItem = (id, items, aborts, finalizeItem) => callAbortOnItem(items[id], aborts, finalizeItem);
const getIsFastAbortNeeded = (count, threshold) => {
  let result = false;
  if (threshold !== 0 && threshold) {
    result = count >= threshold;
  }
  return result;
};
const abortAll = (items, aborts, queue, finalizeItem, options) => {
  const itemIds = Object.values(queue).flat();
  const isFastAbort = getIsFastAbortNeeded(itemIds.length, options.fastAbortThreshold);
  logger.debugLog(`abort: doing abort-all (${isFastAbort ? "fast" : "normal"} abort)`);
  if (isFastAbort) {
    fastAbortAll(aborts);
  } else {
    itemIds.forEach(id => abortItem(id, items, aborts, finalizeItem));
  }
  return {
    isFast: isFastAbort
  };
};
const abortBatch = (batch, batchOptions, aborts, queue, finalizeItem, options) => {
  const threshold = batchOptions.fastAbortThreshold === 0 ? 0 : batchOptions.fastAbortThreshold || options.fastAbortThreshold;
  const isFastAbort = getIsFastAbortNeeded(queue[batch.id].length, threshold);
  logger.debugLog(`abort: doing abort-batch on: ${batch.id} (${isFastAbort ? "fast" : "normal"} abort)`);
  if (isFastAbort) {
    fastAbortBatch(batch, aborts);
  } else {
    batch.items.forEach(bi => callAbortOnItem(bi, aborts, finalizeItem));
  }
  return {
    isFast: isFastAbort
  };
};
export { abortAll, abortBatch, abortItem };