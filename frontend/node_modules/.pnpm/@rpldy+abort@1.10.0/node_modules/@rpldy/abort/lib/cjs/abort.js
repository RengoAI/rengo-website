"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abortItem = exports.abortBatch = exports.abortAll = void 0;
var _shared = require("@rpldy/shared");
var _fastAbort = require("./fastAbort");
const abortNonUploadingItem = (item, aborts, finalizeItem) => {
  _shared.logger.debugLog(`abort: aborting ${item.state} item  - `, item);
  finalizeItem(item.id, {
    status: 0,
    state: _shared.FILE_STATES.ABORTED,
    response: "aborted"
  });
  return true;
};
const ITEM_STATE_ABORTS = {
  [_shared.FILE_STATES.UPLOADING]: (item, aborts) => {
    _shared.logger.debugLog(`abort: aborting uploading item  - `, item);
    return aborts[item.id]();
  },
  [_shared.FILE_STATES.ADDED]: abortNonUploadingItem,
  [_shared.FILE_STATES.PENDING]: abortNonUploadingItem
};
const callAbortOnItem = (item, aborts, finalizeItem) => {
  const itemState = item?.state;
  const method = !!itemState && ITEM_STATE_ABORTS[itemState];
  return method ? method(item, aborts, finalizeItem) : false;
};
const abortItem = (id, items, aborts, finalizeItem) => callAbortOnItem(items[id], aborts, finalizeItem);
exports.abortItem = abortItem;
const getIsFastAbortNeeded = (count, threshold) => {
  let result = false;
  if (threshold !== 0 && threshold) {
    result = count >= threshold;
  }
  return result;
};
const abortAll = (items, aborts, queue, finalizeItem, options) => {
  const itemIds = Object.values(queue).flat();
  const isFastAbort = getIsFastAbortNeeded(itemIds.length, options.fastAbortThreshold);
  _shared.logger.debugLog(`abort: doing abort-all (${isFastAbort ? "fast" : "normal"} abort)`);
  if (isFastAbort) {
    (0, _fastAbort.fastAbortAll)(aborts);
  } else {
    itemIds.forEach(id => abortItem(id, items, aborts, finalizeItem));
  }
  return {
    isFast: isFastAbort
  };
};
exports.abortAll = abortAll;
const abortBatch = (batch, batchOptions, aborts, queue, finalizeItem, options) => {
  const threshold = batchOptions.fastAbortThreshold === 0 ? 0 : batchOptions.fastAbortThreshold || options.fastAbortThreshold;
  const isFastAbort = getIsFastAbortNeeded(queue[batch.id].length, threshold);
  _shared.logger.debugLog(`abort: doing abort-batch on: ${batch.id} (${isFastAbort ? "fast" : "normal"} abort)`);
  if (isFastAbort) {
    (0, _fastAbort.fastAbortBatch)(batch, aborts);
  } else {
    batch.items.forEach(bi => callAbortOnItem(bi, aborts, finalizeItem));
  }
  return {
    isFast: isFastAbort
  };
};
exports.abortBatch = abortBatch;