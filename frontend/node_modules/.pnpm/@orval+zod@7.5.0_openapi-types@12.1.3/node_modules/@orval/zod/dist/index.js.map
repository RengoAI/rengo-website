{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  camel,\n  ClientBuilder,\n  ClientGeneratorsBuilder,\n  ContextSpecs,\n  escape,\n  generateMutator,\n  GeneratorDependency,\n  GeneratorMutator,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  getFileInfo,\n  getNumberWord,\n  getRefInfo,\n  isBoolean,\n  isObject,\n  isString,\n  jsStringEscape,\n  pascal,\n  resolveRef,\n  ZodCoerceType,\n} from '@orval/core';\nimport uniq from 'lodash.uniq';\nimport {\n  ParameterObject,\n  PathItemObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponseObject,\n  SchemaObject,\n} from 'openapi3-ts/oas30';\nimport { SchemaObject as SchemaObject31 } from 'openapi3-ts/oas31';\n\nconst ZOD_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'z',\n        alias: 'zod',\n        values: true,\n      },\n    ],\n    dependency: 'zod',\n  },\n];\n\nexport const getZodDependencies = () => ZOD_DEPENDENCIES;\n\n/**\n * values that may appear in \"type\". Equals SchemaObjectType\n */\nconst possibleSchemaTypes = [\n  'integer',\n  'number',\n  'string',\n  'boolean',\n  'object',\n  'null',\n  'array',\n];\n\nconst resolveZodType = (schema: SchemaObject) => {\n  const schemaTypeValue = schema.type;\n  const type = Array.isArray(schemaTypeValue)\n    ? schemaTypeValue.find((t) => possibleSchemaTypes.includes(t))\n    : schemaTypeValue;\n\n  // TODO: if \"prefixItems\" exists and type is \"array\", then generate a \"tuple\"\n  if (schema.type === 'array' && 'prefixItems' in schema) {\n    return 'tuple';\n  }\n\n  switch (type) {\n    case 'integer':\n      return 'number';\n    default:\n      return type ?? 'any';\n  }\n};\n\nconst constsUniqueCounter: Record<string, number> = {};\n\n// https://github.com/colinhacks/zod#coercion-for-primitives\nconst COERCIBLE_TYPES = ['string', 'number', 'boolean', 'bigint', 'date'];\n\nexport type ZodValidationSchemaDefinition = {\n  functions: [string, any][];\n  consts: string[];\n};\n\nconst minAndMaxTypes = ['number', 'string', 'array'];\n\nconst removeReadOnlyProperties = (schema: SchemaObject): SchemaObject => {\n  if (schema.properties) {\n    return {\n      ...schema,\n      properties: Object.entries(schema.properties).reduce<\n        Record<string, SchemaObject>\n      >((acc, [key, value]) => {\n        if ('readOnly' in value && value.readOnly) return acc;\n        acc[key] = value as SchemaObject;\n        return acc;\n      }, {}),\n    };\n  }\n  if (schema.items && 'properties' in schema.items) {\n    return {\n      ...schema,\n      items: removeReadOnlyProperties(schema.items as SchemaObject),\n    };\n  }\n  return schema;\n};\n\nexport const generateZodValidationSchemaDefinition = (\n  schema: SchemaObject | undefined,\n  context: ContextSpecs,\n  name: string,\n  strict: boolean,\n  rules?: {\n    required?: boolean;\n  },\n): ZodValidationSchemaDefinition => {\n  if (!schema) return { functions: [], consts: [] };\n\n  const consts: string[] = [];\n  const constsCounter =\n    typeof constsUniqueCounter[name] === 'number'\n      ? constsUniqueCounter[name] + 1\n      : 0;\n\n  const constsCounterValue = constsCounter\n    ? pascal(getNumberWord(constsCounter))\n    : '';\n\n  constsUniqueCounter[name] = constsCounter;\n\n  const functions: [string, any][] = [];\n  const type = resolveZodType(schema);\n  const required =\n    schema.default !== undefined ? false : rules?.required ?? false;\n  const nullable =\n    schema.nullable ??\n    (Array.isArray(schema.type) && schema.type.includes('null'));\n  const min = schema.minimum ?? schema.minLength ?? schema.minItems;\n  const max = schema.maximum ?? schema.maxLength ?? schema.maxItems;\n  const matches = schema.pattern ?? undefined;\n\n  switch (type) {\n    case 'tuple':\n      /**\n       *\n       * > 10.3.1.1. prefixItems\n       * > The value of \"prefixItems\" MUST be a non-empty array of valid JSON Schemas.\n       * >\n       * > Validation succeeds if each element of the instance validates against the schema at the same position, if any.\n       * > This keyword does not constrain the length of the array. If the array is longer than this keyword's value,\n       * > this keyword validates only the prefix of matching length.\n       * >\n       * > This keyword produces an annotation value which is the largest index to which this keyword applied a subschema.\n       * > The value MAY be a boolean true if a subschema was applied to every index of the instance, such as is produced by the \"items\" keyword.\n       * > This annotation affects the behavior of \"items\" and \"unevaluatedItems\".\n       * >\n       * > Omitting this keyword has the same assertion behavior as an empty array.\n       */\n      if ('prefixItems' in schema) {\n        const schema31 = schema as SchemaObject31;\n\n        if (schema31.prefixItems && schema31.prefixItems.length > 0) {\n          functions.push([\n            'tuple',\n            schema31.prefixItems.map((item, idx) =>\n              generateZodValidationSchemaDefinition(\n                deference(item as SchemaObject | ReferenceObject, context),\n                context,\n                camel(`${name}-${idx}-item`),\n                strict,\n                {\n                  required: true,\n                },\n              ),\n            ),\n          ]);\n\n          if (schema.items) {\n            if (\n              (max || Number.POSITIVE_INFINITY) > schema31.prefixItems.length\n            ) {\n              // only add zod.rest() if number of tuple elements can exceed provided prefixItems:\n              functions.push([\n                'rest',\n                generateZodValidationSchemaDefinition(\n                  schema.items as SchemaObject | undefined,\n                  context,\n                  camel(`${name}-item`),\n                  strict,\n                  {\n                    required: true,\n                  },\n                ),\n              ]);\n            }\n          }\n        }\n      }\n      break;\n    case 'array':\n      functions.push([\n        'array',\n        generateZodValidationSchemaDefinition(\n          schema.items as SchemaObject | undefined,\n          context,\n          camel(`${name}-item`),\n          strict,\n          {\n            required: true,\n          },\n        ),\n      ]);\n      break;\n    case 'string': {\n      if (schema.enum && type === 'string') {\n        break;\n      }\n\n      if (\n        context.output.override.useDates &&\n        (schema.format === 'date' || schema.format === 'date-time')\n      ) {\n        functions.push(['date', undefined]);\n        break;\n      }\n\n      functions.push([type as string, undefined]);\n\n      if (schema.format === 'date') {\n        functions.push(['date', undefined]);\n        break;\n      }\n\n      if (schema.format === 'date-time') {\n        functions.push(['datetime', undefined]);\n        break;\n      }\n\n      if (schema.format === 'email') {\n        functions.push(['email', undefined]);\n        break;\n      }\n\n      if (schema.format === 'uri' || schema.format === 'hostname') {\n        functions.push(['url', undefined]);\n        break;\n      }\n\n      if (schema.format === 'uuid') {\n        functions.push(['uuid', undefined]);\n        break;\n      }\n\n      break;\n    }\n    case 'object':\n    default: {\n      if (schema.allOf || schema.oneOf || schema.anyOf) {\n        const separator = schema.allOf\n          ? 'allOf'\n          : schema.oneOf\n            ? 'oneOf'\n            : 'anyOf';\n\n        const schemas = (schema.allOf ?? schema.oneOf ?? schema.anyOf) as (\n          | SchemaObject\n          | ReferenceObject\n        )[];\n\n        functions.push([\n          separator,\n          schemas.map((schema) =>\n            generateZodValidationSchemaDefinition(\n              schema as SchemaObject,\n              context,\n              camel(name),\n              strict,\n              {\n                required: true,\n              },\n            ),\n          ),\n        ]);\n        break;\n      }\n\n      if (schema.properties) {\n        functions.push([\n          'object',\n          Object.keys(schema.properties)\n            .map((key) => ({\n              [key]: generateZodValidationSchemaDefinition(\n                schema.properties?.[key] as any,\n                context,\n                camel(`${name}-${key}`),\n                strict,\n                {\n                  required: schema.required?.includes(key),\n                },\n              ),\n            }))\n            .reduce((acc, curr) => ({ ...acc, ...curr }), {}),\n        ]);\n\n        if (strict) {\n          functions.push(['strict', undefined]);\n        }\n\n        break;\n      }\n\n      if (schema.additionalProperties) {\n        functions.push([\n          'additionalProperties',\n          generateZodValidationSchemaDefinition(\n            isBoolean(schema.additionalProperties)\n              ? {}\n              : (schema.additionalProperties as SchemaObject),\n            context,\n            name,\n            strict,\n            {\n              required: true,\n            },\n          ),\n        ]);\n\n        break;\n      }\n\n      functions.push([type as string, undefined]);\n\n      break;\n    }\n  }\n\n  if (minAndMaxTypes.includes(type)) {\n    if (min !== undefined) {\n      if (min === 1) {\n        functions.push(['min', `${min}`]);\n      } else {\n        consts.push(`export const ${name}Min${constsCounterValue} = ${min};\\n`);\n        functions.push(['min', `${name}Min${constsCounterValue}`]);\n      }\n    }\n    if (max !== undefined) {\n      consts.push(`export const ${name}Max${constsCounterValue} = ${max};\\n`);\n      functions.push(['max', `${name}Max${constsCounterValue}`]);\n    }\n  }\n\n  if (matches) {\n    const isStartWithSlash = matches.startsWith('/');\n    const isEndWithSlash = matches.endsWith('/');\n\n    const regexp = `new RegExp('${jsStringEscape(\n      matches.slice(isStartWithSlash ? 1 : 0, isEndWithSlash ? -1 : undefined),\n    )}')`;\n\n    consts.push(\n      `export const ${name}RegExp${constsCounterValue} = ${regexp};\\n`,\n    );\n    functions.push(['regex', `${name}RegExp${constsCounterValue}`]);\n  }\n\n  if (schema.enum && type !== 'number') {\n    functions.push([\n      'enum',\n      [\n        `[${schema.enum\n          .map((value) => (isString(value) ? `'${escape(value)}'` : `${value}`))\n          .join(', ')}]`,\n      ],\n    ]);\n  }\n\n  if (!required && nullable) {\n    functions.push(['nullish', undefined]);\n  } else if (nullable) {\n    functions.push(['nullable', undefined]);\n  } else if (!required) {\n    functions.push(['optional', undefined]);\n  }\n\n  return { functions, consts: uniq(consts) };\n};\n\nexport const parseZodValidationSchemaDefinition = (\n  input: ZodValidationSchemaDefinition,\n  context: ContextSpecs,\n  coerceTypes: boolean | ZodCoerceType[] = false,\n  preprocessResponse?: GeneratorMutator,\n): { zod: string; consts: string } => {\n  if (!input.functions.length) {\n    return { zod: '', consts: '' };\n  }\n\n  let consts = '';\n\n  const parseProperty = (property: [string, any]): string => {\n    const [fn, args = ''] = property;\n    if (fn === 'allOf') {\n      return args.reduce(\n        (acc: string, { functions }: { functions: [string, any][] }) => {\n          const value = functions.map(parseProperty).join('');\n          const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n\n          if (!acc) {\n            acc += valueWithZod;\n            return acc;\n          }\n\n          acc += `.and(${valueWithZod})`;\n\n          return acc;\n        },\n        '',\n      );\n    }\n\n    if (fn === 'oneOf' || fn === 'anyOf') {\n      return args.reduce(\n        (\n          acc: string,\n          {\n            functions,\n            consts: argConsts,\n          }: { functions: [string, any][]; consts: string[] },\n        ) => {\n          const value = functions.map(parseProperty).join('');\n          const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n\n          if (argConsts.length) {\n            consts += argConsts.join('');\n          }\n\n          if (!acc) {\n            acc += valueWithZod;\n            return acc;\n          }\n\n          acc += `.or(${valueWithZod})`;\n\n          return acc;\n        },\n        '',\n      );\n    }\n\n    if (fn === 'additionalProperties') {\n      const value = args.functions.map(parseProperty).join('');\n      const valueWithZod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n      consts += args.consts;\n      return `zod.record(zod.string(), ${valueWithZod})`;\n    }\n\n    if (fn === 'object') {\n      return `zod.object({\n${Object.entries(args)\n  .map(([key, schema]) => {\n    const value = (schema as ZodValidationSchemaDefinition).functions\n      .map(parseProperty)\n      .join('');\n    consts += (schema as ZodValidationSchemaDefinition).consts.join('\\n');\n    return `  \"${key}\": ${value.startsWith('.') ? 'zod' : ''}${value}`;\n  })\n  .join(',\\n')}\n})`;\n    }\n    if (fn === 'array') {\n      const value = args.functions.map(parseProperty).join('');\n      if (typeof args.consts === 'string') {\n        consts += args.consts;\n      } else if (Array.isArray(args.consts)) {\n        consts += args.consts.join('\\n');\n      }\n      return `.array(${value.startsWith('.') ? 'zod' : ''}${value})`;\n    }\n\n    if (fn === 'strict') {\n      return '.strict()';\n    }\n\n    if (fn === 'tuple') {\n      return `zod.tuple([${(args as ZodValidationSchemaDefinition[])\n        .map((x) => 'zod' + x.functions.map(parseProperty).join(','))\n        .join(',\\n')}])`;\n    }\n    if (fn === 'rest') {\n      return `.rest(zod${(args as ZodValidationSchemaDefinition).functions.map(parseProperty)})`;\n    }\n    const shouldCoerceType =\n      coerceTypes &&\n      (Array.isArray(coerceTypes)\n        ? coerceTypes.includes(fn as ZodCoerceType)\n        : COERCIBLE_TYPES.includes(fn));\n\n    if (\n      (fn !== 'date' && shouldCoerceType) ||\n      (fn === 'date' && shouldCoerceType && context.output.override.useDates)\n    ) {\n      return `.coerce.${fn}(${args})`;\n    }\n\n    return `.${fn}(${args})`;\n  };\n\n  consts += input.consts.join('\\n');\n\n  const schema = input.functions.map(parseProperty).join('');\n  const value = preprocessResponse\n    ? `.preprocess(${preprocessResponse.name}, ${\n        schema.startsWith('.') ? 'zod' : ''\n      }${schema})`\n    : schema;\n\n  const zod = `${value.startsWith('.') ? 'zod' : ''}${value}`;\n\n  return { zod, consts };\n};\n\nconst deferenceScalar = (value: any, context: ContextSpecs): unknown => {\n  if (isObject(value)) {\n    return deference(value, context);\n  } else if (Array.isArray(value)) {\n    return value.map((item) => deferenceScalar(item, context));\n  } else {\n    return value;\n  }\n};\n\nconst deference = (\n  schema: SchemaObject | ReferenceObject,\n  context: ContextSpecs,\n): SchemaObject => {\n  const refName = '$ref' in schema ? schema.$ref : undefined;\n  if (refName && context.parents?.includes(refName)) {\n    return {};\n  }\n\n  const childContext: ContextSpecs = {\n    ...context,\n    ...(refName\n      ? { parents: [...(context.parents || []), refName] }\n      : undefined),\n  };\n\n  const { schema: resolvedSchema } = resolveRef<SchemaObject>(\n    schema,\n    childContext,\n  );\n\n  const resolvedSpecKey = refName\n    ? getRefInfo(refName, context).specKey\n    : undefined;\n\n  const resolvedContext: ContextSpecs = {\n    ...childContext,\n    specKey: resolvedSpecKey ?? childContext.specKey,\n  };\n\n  return Object.entries(resolvedSchema).reduce((acc, [key, value]) => {\n    acc[key] = deferenceScalar(value, resolvedContext);\n    return acc;\n  }, {} as any);\n};\n\nconst parseBodyAndResponse = ({\n  data,\n  context,\n  name,\n  strict,\n  generate,\n  parseType,\n}: {\n  data: ResponseObject | RequestBodyObject | ReferenceObject | undefined;\n  context: ContextSpecs;\n  name: string;\n  strict: boolean;\n  generate: boolean;\n  parseType: 'body' | 'response';\n}): {\n  input: ZodValidationSchemaDefinition;\n  isArray: boolean;\n  rules?: {\n    min?: number;\n    max?: number;\n  };\n} => {\n  if (!data || !generate) {\n    return {\n      input: { functions: [], consts: [] },\n      isArray: false,\n    };\n  }\n\n  const resolvedRef = resolveRef<ResponseObject | RequestBodyObject>(\n    data,\n    context,\n  ).schema;\n\n  if (!resolvedRef.content?.['application/json']?.schema) {\n    return {\n      input: { functions: [], consts: [] },\n      isArray: false,\n    };\n  }\n\n  const resolvedJsonSchema = deference(\n    resolvedRef.content['application/json'].schema,\n    context,\n  );\n\n  // keep the same behaviour for array\n  if (resolvedJsonSchema.items) {\n    const min =\n      resolvedJsonSchema.minimum ??\n      resolvedJsonSchema.minLength ??\n      resolvedJsonSchema.minItems;\n    const max =\n      resolvedJsonSchema.maximum ??\n      resolvedJsonSchema.maxLength ??\n      resolvedJsonSchema.maxItems;\n\n    return {\n      input: generateZodValidationSchemaDefinition(\n        parseType === 'body'\n          ? removeReadOnlyProperties(resolvedJsonSchema.items as SchemaObject)\n          : (resolvedJsonSchema.items as SchemaObject),\n        context,\n        name,\n        strict,\n        {\n          required: true,\n        },\n      ),\n      isArray: true,\n      rules: {\n        ...(typeof min !== 'undefined' ? { min } : {}),\n        ...(typeof max !== 'undefined' ? { max } : {}),\n      },\n    };\n  }\n\n  return {\n    input: generateZodValidationSchemaDefinition(\n      parseType === 'body'\n        ? removeReadOnlyProperties(resolvedJsonSchema)\n        : resolvedJsonSchema,\n      context,\n      name,\n      strict,\n      {\n        required: true,\n      },\n    ),\n    isArray: false,\n  };\n};\n\nconst parseParameters = ({\n  data,\n  context,\n  operationName,\n  strict,\n  generate,\n}: {\n  data: (ParameterObject | ReferenceObject)[] | undefined;\n  context: ContextSpecs;\n  operationName: string;\n  strict: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n  generate: {\n    param: boolean;\n    query: boolean;\n    header: boolean;\n    body: boolean;\n    response: boolean;\n  };\n}): {\n  headers: ZodValidationSchemaDefinition;\n  queryParams: ZodValidationSchemaDefinition;\n  params: ZodValidationSchemaDefinition;\n} => {\n  if (!data) {\n    return {\n      headers: {\n        functions: [],\n        consts: [],\n      },\n      queryParams: {\n        functions: [],\n        consts: [],\n      },\n      params: {\n        functions: [],\n        consts: [],\n      },\n    };\n  }\n\n  const defintionsByParameters = data.reduce(\n    (acc, val) => {\n      const { schema: parameter } = resolveRef<ParameterObject>(val, context);\n\n      if (!parameter.schema) {\n        return acc;\n      }\n\n      const schema = deference(parameter.schema, context);\n\n      const mapStrict = {\n        path: strict.param,\n        query: strict.query,\n        header: strict.header,\n      };\n\n      const mapGenerate = {\n        path: generate.param,\n        query: generate.query,\n        header: generate.header,\n      };\n\n      const definition = generateZodValidationSchemaDefinition(\n        schema,\n        context,\n        camel(`${operationName}-${parameter.in}-${parameter.name}`),\n        mapStrict[parameter.in as 'path' | 'query' | 'header'] ?? false,\n        {\n          required: parameter.required,\n        },\n      );\n\n      if (parameter.in === 'header' && mapGenerate.header) {\n        return {\n          ...acc,\n          headers: { ...acc.headers, [parameter.name]: definition },\n        };\n      }\n\n      if (parameter.in === 'query' && mapGenerate.query) {\n        return {\n          ...acc,\n          queryParams: { ...acc.queryParams, [parameter.name]: definition },\n        };\n      }\n\n      if (parameter.in === 'path' && mapGenerate.path) {\n        return {\n          ...acc,\n          params: { ...acc.params, [parameter.name]: definition },\n        };\n      }\n\n      return acc;\n    },\n    {\n      headers: {},\n      queryParams: {},\n      params: {},\n    } as Record<\n      'headers' | 'queryParams' | 'params',\n      Record<string, { functions: [string, any][]; consts: string[] }>\n    >,\n  );\n\n  const headers: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.headers).length) {\n    headers.functions.push(['object', defintionsByParameters.headers]);\n\n    if (strict.header) {\n      headers.functions.push(['strict', undefined]);\n    }\n  }\n\n  const queryParams: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.queryParams).length) {\n    queryParams.functions.push(['object', defintionsByParameters.queryParams]);\n\n    if (strict.query) {\n      queryParams.functions.push(['strict', undefined]);\n    }\n  }\n\n  const params: ZodValidationSchemaDefinition = {\n    functions: [],\n    consts: [],\n  };\n\n  if (Object.keys(defintionsByParameters.params).length) {\n    params.functions.push(['object', defintionsByParameters.params]);\n\n    if (strict.param) {\n      params.functions.push(['strict', undefined]);\n    }\n  }\n\n  return {\n    headers,\n    queryParams,\n    params,\n  };\n};\n\nconst generateZodRoute = async (\n  { operationName, verb, override }: GeneratorVerbOptions,\n  { pathRoute, context, output }: GeneratorOptions,\n) => {\n  const spec = context.specs[context.specKey].paths[pathRoute] as\n    | PathItemObject\n    | undefined;\n\n  const parameters = spec?.[verb]?.parameters as (\n    | ParameterObject\n    | ReferenceObject\n  )[];\n  const parsedParameters = parseParameters({\n    data: parameters,\n    context,\n    operationName,\n    strict: override.zod.strict,\n    generate: override.zod.generate,\n  });\n\n  const requestBody = spec?.[verb]?.requestBody;\n  const parsedBody = parseBodyAndResponse({\n    data: requestBody,\n    context,\n    name: camel(`${operationName}-body`),\n    strict: override.zod.strict.body,\n    generate: override.zod.generate.body,\n    parseType: 'body',\n  });\n\n  const responses = (\n    context.output.override.zod.generateEachHttpStatus\n      ? Object.entries(spec?.[verb]?.responses ?? {})\n      : [['', spec?.[verb]?.responses[200]]]\n  ) as [string, ResponseObject | ReferenceObject][];\n  const parsedResponses = responses.map(([code, response]) =>\n    parseBodyAndResponse({\n      data: response,\n      context,\n      name: camel(`${operationName}-${code}-response`),\n      strict: override.zod.strict.response,\n      generate: override.zod.generate.response,\n      parseType: 'response',\n    }),\n  );\n\n  const inputParams = parseZodValidationSchemaDefinition(\n    parsedParameters.params,\n    context,\n    override.zod.coerce.param,\n  );\n\n  if (override.coerceTypes) {\n    console.warn(\n      'override.coerceTypes is deprecated, please use override.zod.coerce instead.',\n    );\n  }\n\n  const inputQueryParams = parseZodValidationSchemaDefinition(\n    parsedParameters.queryParams,\n    context,\n    override.zod.coerce.query ?? override.coerceTypes,\n  );\n  const inputHeaders = parseZodValidationSchemaDefinition(\n    parsedParameters.headers,\n    context,\n    override.zod.coerce.header,\n  );\n\n  const inputBody = parseZodValidationSchemaDefinition(\n    parsedBody.input,\n    context,\n    override.zod.coerce.body,\n  );\n\n  const preprocessResponse = override.zod.preprocess?.response\n    ? await generateMutator({\n        output,\n        mutator: override.zod.preprocess.response,\n        name: `${operationName}PreprocessResponse`,\n        workspace: context.workspace,\n        tsconfig: context.output.tsconfig,\n      })\n    : undefined;\n\n  const inputResponses = parsedResponses.map((parsedResponse) =>\n    parseZodValidationSchemaDefinition(\n      parsedResponse.input,\n      context,\n      override.zod.coerce.response,\n      preprocessResponse,\n    ),\n  );\n\n  if (\n    !inputParams.zod &&\n    !inputQueryParams.zod &&\n    !inputHeaders.zod &&\n    !inputBody.zod &&\n    !inputResponses.some((inputResponse) => inputResponse.zod)\n  ) {\n    return {\n      implemtation: '',\n      mutators: [],\n    };\n  }\n\n  return {\n    implementation: [\n      ...(inputParams.consts ? [inputParams.consts] : []),\n      ...(inputParams.zod\n        ? [`export const ${operationName}Params = ${inputParams.zod}`]\n        : []),\n      ...(inputQueryParams.consts ? [inputQueryParams.consts] : []),\n      ...(inputQueryParams.zod\n        ? [`export const ${operationName}QueryParams = ${inputQueryParams.zod}`]\n        : []),\n      ...(inputHeaders.consts ? [inputHeaders.consts] : []),\n      ...(inputHeaders.zod\n        ? [`export const ${operationName}Header = ${inputHeaders.zod}`]\n        : []),\n      ...(inputBody.consts ? [inputBody.consts] : []),\n      ...(inputBody.zod\n        ? [\n            parsedBody.isArray\n              ? `export const ${operationName}BodyItem = ${inputBody.zod}\nexport const ${operationName}Body = zod.array(${operationName}BodyItem)${\n                  parsedBody.rules?.min ? `.min(${parsedBody.rules?.min})` : ''\n                }${\n                  parsedBody.rules?.max ? `.max(${parsedBody.rules?.max})` : ''\n                }`\n              : `export const ${operationName}Body = ${inputBody.zod}`,\n          ]\n        : []),\n      ...inputResponses\n        .map((inputResponse, index) => {\n          const operationResponse = camel(\n            `${operationName}-${responses[index][0]}-response`,\n          );\n          return [\n            ...(inputResponse.consts ? [inputResponse.consts] : []),\n            ...(inputResponse.zod\n              ? [\n                  parsedResponses[index].isArray\n                    ? `export const ${operationResponse}Item = ${\n                        inputResponse.zod\n                      }\nexport const ${operationResponse} = zod.array(${operationResponse}Item)${\n                        parsedResponses[index].rules?.min\n                          ? `.min(${parsedResponses[index].rules?.min})`\n                          : ''\n                      }${\n                        parsedResponses[index].rules?.max\n                          ? `.max(${parsedResponses[index].rules?.max})`\n                          : ''\n                      }`\n                    : `export const ${operationResponse} = ${inputResponse.zod}`,\n                ]\n              : []),\n          ];\n        })\n        .flat(),\n    ].join('\\n\\n'),\n    mutators: preprocessResponse ? [preprocessResponse] : [],\n  };\n};\n\nexport const generateZod: ClientBuilder = async (verbOptions, options) => {\n  const { implementation, mutators } = await generateZodRoute(\n    verbOptions,\n    options,\n  );\n\n  return {\n    implementation: implementation ? `${implementation}\\n\\n` : '',\n    imports: [],\n    mutators,\n  };\n};\n\nconst zodClientBuilder: ClientGeneratorsBuilder = {\n  client: generateZod,\n  dependencies: getZodDependencies,\n};\n\nexport const builder = () => () => zodClientBuilder;\n\nexport default builder;\n"],"mappings":"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","names":["schema","_a","_b","uniq","value","_c","_d"]}