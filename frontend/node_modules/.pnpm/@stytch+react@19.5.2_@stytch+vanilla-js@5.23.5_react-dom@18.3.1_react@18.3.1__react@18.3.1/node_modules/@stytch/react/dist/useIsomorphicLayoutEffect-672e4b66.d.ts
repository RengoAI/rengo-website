import { Dispatch, SetStateAction, useEffect } from "react";
declare function invariant(cond: unknown, message: string): asserts cond;
// useState can cause memory leaks if it is set after the component unmounted. For example, if it is
// set after `await`, or in a `then`, `catch`, or `finally`, or in a setTimout/setInterval.
declare const useAsyncState: <T>(initialState: T | (() => T)) => [
    T,
    Dispatch<SetStateAction<T>>
];
/**
 * Returns a version of `newValue` whose properties that are deeply equal to
 * those in `oldValue` are replaced with those from `oldValue`. This provides a
 * limited form of "structural sharing" that provides a stable reference for
 * unchanged slices of the object.
 *
 * If `oldValue` and `newValue` are referentially equal, the same value is
 * returned.
 *
 * @param oldValue The old value
 * @param newValue The new value
 */
declare const mergeWithStableProps: <T extends Record<string, unknown>, U extends Record<string, unknown> = T>(oldValue: U, newValue: T) => T;
declare const useIsomorphicLayoutEffect: typeof useEffect;
export { useIsomorphicLayoutEffect as default, invariant, useAsyncState, mergeWithStableProps };
