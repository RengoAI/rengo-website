"use client"
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ErrorBoundaryGroup.tsx
var ErrorBoundaryGroup_exports = {};
__export(ErrorBoundaryGroup_exports, {
  ErrorBoundaryGroup: () => ErrorBoundaryGroup,
  ErrorBoundaryGroupContext: () => ErrorBoundaryGroupContext,
  useErrorBoundaryGroup: () => useErrorBoundaryGroup
});
module.exports = __toCommonJS(ErrorBoundaryGroup_exports);
var import_react2 = require("react");

// src/hooks/usePrevious.ts
var import_react = require("react");
var usePrevious = (value) => {
  const ref = (0, import_react.useRef)(value);
  (0, import_react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
};

// src/hooks/useIsChanged.ts
var useIsChanged = (value) => usePrevious(value) !== value;

// src/models/SuspensiveError.ts
var SuspensiveError = class _SuspensiveError extends Error {
  static assert(condition, message) {
    if (!condition) {
      throw new _SuspensiveError(message);
    }
  }
};
var Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children = "useErrorBoundaryGroup: this hook should be called in ErrorBoundary.props.children";

// src/utils/increase.ts
var increase = (prev) => prev + 1;

// src/ErrorBoundaryGroup.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var ErrorBoundaryGroupContext = (0, import_react2.createContext)(void 0);
if (process.env.NODE_ENV === "development") {
  ErrorBoundaryGroupContext.displayName = "ErrorBoundaryGroupContext";
}
var ErrorBoundaryGroup = Object.assign(
  (() => {
    const ErrorBoundaryGroup2 = ({ blockOutside = false, children }) => {
      const [resetKey, reset] = (0, import_react2.useReducer)(increase, 0);
      const parentGroup = (0, import_react2.useContext)(ErrorBoundaryGroupContext);
      const isParentGroupResetKeyChanged = useIsChanged(parentGroup == null ? void 0 : parentGroup.resetKey);
      (0, import_react2.useEffect)(() => {
        if (!blockOutside && isParentGroupResetKeyChanged) {
          reset();
        }
      }, [isParentGroupResetKeyChanged, blockOutside]);
      const value = (0, import_react2.useMemo)(() => ({ reset, resetKey }), [resetKey]);
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ErrorBoundaryGroupContext.Provider, { value, children });
    };
    if (process.env.NODE_ENV === "development") {
      ErrorBoundaryGroup2.displayName = "ErrorBoundaryGroup";
    }
    return ErrorBoundaryGroup2;
  })(),
  {
    Consumer: ({
      children
    }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children(useErrorBoundaryGroup()) })
  }
);
var useErrorBoundaryGroup = () => {
  const group = (0, import_react2.useContext)(ErrorBoundaryGroupContext);
  SuspensiveError.assert(
    group != null,
    Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children
  );
  return (0, import_react2.useMemo)(
    () => ({
      /**
       * When you want to reset multiple ErrorBoundaries as children of ErrorBoundaryGroup, You can use this reset
       */
      reset: group.reset
    }),
    [group.reset]
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ErrorBoundaryGroup,
  ErrorBoundaryGroupContext,
  useErrorBoundaryGroup
});
//# sourceMappingURL=ErrorBoundaryGroup.cjs.map