"use client"
"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ClientOnly: () => ClientOnly,
  DefaultProps: () => DefaultProps,
  DefaultPropsProvider: () => DefaultPropsProvider,
  Delay: () => Delay,
  DevMode: () => DevMode,
  ErrorBoundary: () => ErrorBoundary,
  ErrorBoundaryGroup: () => ErrorBoundaryGroup,
  Suspense: () => Suspense2,
  Suspensive: () => Suspensive,
  SuspensiveProvider: () => SuspensiveProvider,
  useErrorBoundary: () => useErrorBoundary,
  useErrorBoundaryFallbackProps: () => useErrorBoundaryFallbackProps,
  useErrorBoundaryGroup: () => useErrorBoundaryGroup,
  wrap: () => wrap
});
module.exports = __toCommonJS(src_exports);

// src/Suspensive.tsx
var import_react2 = require("react");

// src/contexts/DefaultPropsContexts.ts
var import_react = require("react");
var DelayDefaultPropsContext = (0, import_react.createContext)({
  ms: void 0,
  fallback: void 0
});
if (process.env.NODE_ENV === "development") {
  DelayDefaultPropsContext.displayName = "DelayDefaultPropsContext";
}
var SuspenseDefaultPropsContext = (0, import_react.createContext)({
  fallback: void 0,
  clientOnly: void 0
});
if (process.env.NODE_ENV === "development") {
  SuspenseDefaultPropsContext.displayName = "SuspenseDefaultPropsContext";
}

// src/models/SuspensiveError.ts
var SuspensiveError = class _SuspensiveError extends Error {
  static assert(condition, message) {
    if (!condition) {
      throw new _SuspensiveError(message);
    }
  }
};
var Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children = "useErrorBoundary: this hook should be called in ErrorBoundary.props.children";
var Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback = "useErrorBoundaryFallbackProps: this hook should be called in ErrorBoundary.props.fallback";
var Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children = "useErrorBoundaryGroup: this hook should be called in ErrorBoundary.props.children";
var Message_Delay_ms_prop_should_be_greater_than_or_equal_to_0 = "Delay: ms prop should be greater than or equal to 0";
var Message_DefaultProp_delay_ms_should_be_greater_than_0 = "DefaultProps: delay.ms should be greater than 0";

// src/DefaultProps.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var DefaultProps = class {
  constructor(defaultProps = {}) {
    var _a;
    if (process.env.NODE_ENV === "development" && typeof ((_a = defaultProps.Delay) == null ? void 0 : _a.ms) === "number") {
      SuspensiveError.assert(defaultProps.Delay.ms > 0, Message_DefaultProp_delay_ms_should_be_greater_than_0);
    }
    this.Suspense = defaultProps.Suspense;
    this.Delay = defaultProps.Delay;
  }
};
var DefaultPropsProvider = ({ defaultProps, children }) => {
  var _a, _b;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DelayDefaultPropsContext.Provider, { value: (_a = defaultProps.Delay) != null ? _a : {}, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SuspenseDefaultPropsContext.Provider, { value: (_b = defaultProps.Suspense) != null ? _b : {}, children }) });
};

// src/Suspensive.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var Suspensive = class {
  constructor(config = {}) {
    var _a, _b;
    if (process.env.NODE_ENV === "development" && typeof ((_b = (_a = config.defaultProps) == null ? void 0 : _a.delay) == null ? void 0 : _b.ms) === "number") {
      SuspensiveError.assert(config.defaultProps.delay.ms > 0, Message_DefaultProp_delay_ms_should_be_greater_than_0);
    }
    this.defaultProps = config.defaultProps;
  }
};
var SuspensiveProvider = ({ value, children }) => {
  var _a, _b;
  const defaultProps = (0, import_react2.useMemo)(
    () => {
      var _a2, _b2;
      return new DefaultProps({ Delay: (_a2 = value.defaultProps) == null ? void 0 : _a2.delay, Suspense: (_b2 = value.defaultProps) == null ? void 0 : _b2.suspense });
    },
    [(_a = value.defaultProps) == null ? void 0 : _a.delay, (_b = value.defaultProps) == null ? void 0 : _b.suspense]
  );
  return value.defaultProps ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(DefaultPropsProvider, { defaultProps, children }) : /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children });
};

// src/Suspense.tsx
var import_react7 = require("react");

// src/utils/hasResetKeysChanged.ts
var hasResetKeysChanged = (a = [], b = []) => a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));

// src/utils/defineSuspense.tsx
var import_react6 = require("react");

// src/hooks/usePrevious.ts
var import_react3 = require("react");
var usePrevious = (value) => {
  const ref = (0, import_react3.useRef)(value);
  (0, import_react3.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
};

// src/hooks/useIsChanged.ts
var useIsChanged = (value) => usePrevious(value) !== value;

// src/hooks/useIsClient.ts
var import_react4 = require("react");

// src/utils/noop.ts
var noop = () => {
};

// src/hooks/useIsClient.ts
var emptySubscribe = () => noop;
var getSnapshot = () => true;
var getServerSnapshot = () => false;
var useIsClient = () => (0, import_react4.useSyncExternalStore)(emptySubscribe, getSnapshot, getServerSnapshot);

// src/hooks/useTimeout.ts
var import_react5 = require("react");
var useTimeout = (fn, ms) => {
  const fnRef = (0, import_react5.useRef)(fn);
  fnRef.current = fn;
  const fnPreserved = (0, import_react5.useCallback)(() => fnRef.current(), []);
  (0, import_react5.useEffect)(() => {
    const id = setTimeout(fnPreserved, ms);
    return () => clearTimeout(id);
  }, [fnPreserved, ms]);
};

// src/ClientOnly.tsx
var import_jsx_runtime3 = require("react/jsx-runtime");
var ClientOnly = ({ children, fallback }) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: useIsClient() ? children : fallback });

// src/utils/defineSuspense.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var SuspenseClientOnly = (props) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ClientOnly, { fallback: props.fallback, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_react6.Suspense, __spreadValues({}, props)) });
function defineSuspense({
  defaultPropsClientOnly,
  componentPropsClientOnly
}) {
  return (componentPropsClientOnly != null ? componentPropsClientOnly : defaultPropsClientOnly) ? SuspenseClientOnly : import_react6.Suspense;
}

// src/utils/increase.ts
var increase = (prev) => prev + 1;

// src/Suspense.tsx
var import_jsx_runtime5 = require("react/jsx-runtime");
var Suspense2 = ({ clientOnly, children, fallback }) => {
  const defaultProps = (0, import_react7.useContext)(SuspenseDefaultPropsContext);
  const DefinedSuspense = defineSuspense({
    defaultPropsClientOnly: defaultProps.clientOnly,
    componentPropsClientOnly: clientOnly
  });
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(DefinedSuspense, { fallback: fallback === void 0 ? defaultProps.fallback : fallback, children });
};
if (process.env.NODE_ENV === "development") {
  Suspense2.displayName = "Suspense";
}

// src/ErrorBoundary.tsx
var import_react9 = require("react");

// src/ErrorBoundaryGroup.tsx
var import_react8 = require("react");
var import_jsx_runtime6 = require("react/jsx-runtime");
var ErrorBoundaryGroupContext = (0, import_react8.createContext)(void 0);
if (process.env.NODE_ENV === "development") {
  ErrorBoundaryGroupContext.displayName = "ErrorBoundaryGroupContext";
}
var ErrorBoundaryGroup = Object.assign(
  (() => {
    const ErrorBoundaryGroup2 = ({ blockOutside = false, children }) => {
      const [resetKey, reset] = (0, import_react8.useReducer)(increase, 0);
      const parentGroup = (0, import_react8.useContext)(ErrorBoundaryGroupContext);
      const isParentGroupResetKeyChanged = useIsChanged(parentGroup == null ? void 0 : parentGroup.resetKey);
      (0, import_react8.useEffect)(() => {
        if (!blockOutside && isParentGroupResetKeyChanged) {
          reset();
        }
      }, [isParentGroupResetKeyChanged, blockOutside]);
      const value = (0, import_react8.useMemo)(() => ({ reset, resetKey }), [resetKey]);
      return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(ErrorBoundaryGroupContext.Provider, { value, children });
    };
    if (process.env.NODE_ENV === "development") {
      ErrorBoundaryGroup2.displayName = "ErrorBoundaryGroup";
    }
    return ErrorBoundaryGroup2;
  })(),
  {
    Consumer: ({
      children
    }) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: children(useErrorBoundaryGroup()) })
  }
);
var useErrorBoundaryGroup = () => {
  const group = (0, import_react8.useContext)(ErrorBoundaryGroupContext);
  SuspensiveError.assert(
    group != null,
    Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children
  );
  return (0, import_react8.useMemo)(
    () => ({
      /**
       * When you want to reset multiple ErrorBoundaries as children of ErrorBoundaryGroup, You can use this reset
       */
      reset: group.reset
    }),
    [group.reset]
  );
};

// src/ErrorBoundary.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
var checkErrorBoundary = (shouldCatch, error) => {
  if (typeof shouldCatch === "boolean") {
    return shouldCatch;
  }
  if (shouldCatch.prototype instanceof Error) {
    return error instanceof shouldCatch;
  }
  return shouldCatch(error);
};
var initialErrorBoundaryState = {
  isError: false,
  error: null
};
var BaseErrorBoundary = class extends import_react9.Component {
  constructor() {
    super(...arguments);
    this.state = initialErrorBoundaryState;
    this.reset = () => {
      var _a, _b;
      (_b = (_a = this.props).onReset) == null ? void 0 : _b.call(_a);
      this.setState(initialErrorBoundaryState);
    };
  }
  static getDerivedStateFromError(error) {
    return { isError: true, error };
  }
  componentDidUpdate(prevProps, prevState) {
    const { isError } = this.state;
    const { resetKeys } = this.props;
    if (isError && prevState.isError && hasResetKeysChanged(prevProps.resetKeys, resetKeys)) {
      this.reset();
    }
  }
  componentDidCatch(error, info) {
    var _a, _b;
    (_b = (_a = this.props).onError) == null ? void 0 : _b.call(_a, error, info);
  }
  render() {
    const { children, fallback, shouldCatch = true } = this.props;
    const { isError, error } = this.state;
    let childrenOrFallback = children;
    if (isError) {
      if (error instanceof SuspensiveError) {
        throw error;
      }
      const isCatch = Array.isArray(shouldCatch) ? shouldCatch.some((shouldCatch2) => checkErrorBoundary(shouldCatch2, error)) : checkErrorBoundary(shouldCatch, error);
      if (!isCatch) {
        throw error;
      }
      if (typeof fallback === "undefined") {
        if (process.env.NODE_ENV === "development") {
          console.error("ErrorBoundary of @suspensive/react requires a defined fallback");
        }
        throw error;
      }
      if (typeof fallback === "function") {
        const FallbackComponent = fallback;
        childrenOrFallback = /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(FallbackComponent, { error, reset: this.reset });
      } else {
        childrenOrFallback = fallback;
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ErrorBoundaryContext.Provider, { value: __spreadProps(__spreadValues({}, this.state), { reset: this.reset }), children: childrenOrFallback });
  }
};
var ErrorBoundary = Object.assign(
  (() => {
    const ErrorBoundary2 = (0, import_react9.forwardRef)(
      // TODO: remove this line
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ({ fallback, children, onError, onReset, resetKeys, shouldCatch }, ref) => {
        var _a;
        const group = (_a = (0, import_react9.useContext)(ErrorBoundaryGroupContext)) != null ? _a : { resetKey: 0 };
        const baseErrorBoundaryRef = (0, import_react9.useRef)(null);
        (0, import_react9.useImperativeHandle)(ref, () => ({
          reset: () => {
            var _a2;
            return (_a2 = baseErrorBoundaryRef.current) == null ? void 0 : _a2.reset();
          }
        }));
        return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
          BaseErrorBoundary,
          {
            shouldCatch,
            fallback,
            onError,
            onReset,
            resetKeys: [group.resetKey, ...resetKeys || []],
            ref: baseErrorBoundaryRef,
            children
          }
        );
      }
    );
    if (process.env.NODE_ENV === "development") {
      ErrorBoundary2.displayName = "ErrorBoundary";
    }
    return ErrorBoundary2;
  })(),
  {
    Consumer: ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: children(useErrorBoundary()) })
  }
);
var ErrorBoundaryContext = (0, import_react9.createContext)(null);
if (process.env.NODE_ENV === "development") {
  ErrorBoundaryContext.displayName = "ErrorBoundaryContext";
}
var useErrorBoundary = () => {
  const [state, setState] = (0, import_react9.useState)({
    isError: false,
    error: null
  });
  if (state.isError) {
    throw state.error;
  }
  const errorBoundary = (0, import_react9.useContext)(ErrorBoundaryContext);
  SuspensiveError.assert(
    errorBoundary != null && !errorBoundary.isError,
    Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children
  );
  return (0, import_react9.useMemo)(
    () => ({
      setError: (error) => setState({ isError: true, error })
    }),
    []
  );
};
var useErrorBoundaryFallbackProps = () => {
  const errorBoundary = (0, import_react9.useContext)(ErrorBoundaryContext);
  SuspensiveError.assert(
    errorBoundary != null && errorBoundary.isError,
    Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback
  );
  return (0, import_react9.useMemo)(
    () => ({
      error: errorBoundary.error,
      reset: errorBoundary.reset
    }),
    [errorBoundary.error, errorBoundary.reset]
  );
};

// src/Delay.tsx
var import_react10 = require("react");
var import_jsx_runtime8 = require("react/jsx-runtime");
var Delay = (props) => {
  var _a, _b;
  if (process.env.NODE_ENV === "development" && typeof props.ms === "number") {
    SuspensiveError.assert(props.ms >= 0, Message_Delay_ms_prop_should_be_greater_than_or_equal_to_0);
  }
  const defaultProps = (0, import_react10.useContext)(DelayDefaultPropsContext);
  const ms = (_b = (_a = props.ms) != null ? _a : defaultProps.ms) != null ? _b : 0;
  const [isDelayed, setIsDelayed] = (0, import_react10.useState)(ms <= 0);
  useTimeout(() => setIsDelayed(true), ms);
  if (typeof props.children === "function") {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: props.children({ isDelayed }) });
  }
  if (isDelayed) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: props.children });
  }
  if (props.fallback === void 0) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: defaultProps.fallback });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: props.fallback });
};
if (process.env.NODE_ENV === "development") {
  Delay.displayName = "Delay";
}

// src/wrap.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
var Wrap = class {
  constructor(wrappers) {
    this.wrappers = wrappers;
    this.Suspense = (props = {}) => {
      this.wrappers.unshift([Suspense2, props]);
      return this;
    };
    this.ErrorBoundary = (props) => {
      this.wrappers.unshift([ErrorBoundary, props]);
      return this;
    };
    this.ErrorBoundaryGroup = (props = {}) => {
      this.wrappers.unshift([ErrorBoundaryGroup, props]);
      return this;
    };
    this.Delay = (props = {}) => {
      this.wrappers.unshift([Delay, props]);
      return this;
    };
    this.on = (Component2) => {
      const WrappedComponent = (props) => this.wrappers.reduce(
        (acc, [WrapperComponent, wrapperProps]) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(WrapperComponent, __spreadProps(__spreadValues({}, wrapperProps), { children: acc })),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Component2, __spreadValues({}, props))
      );
      if (process.env.NODE_ENV === "development") {
        WrappedComponent.displayName = "wrap.".concat([...this.wrappers].reverse().map(([WrapperComponent]) => WrapperComponent.displayName).join("."), ".on(").concat(Component2.displayName || Component2.name || "Component", ")");
      }
      return WrappedComponent;
    };
  }
};
var wrap = {
  Suspense: (props = {}) => new Wrap([[Suspense2, props]]),
  ErrorBoundary: (props) => new Wrap([[ErrorBoundary, props]]),
  ErrorBoundaryGroup: (props) => new Wrap([[ErrorBoundaryGroup, props]]),
  Delay: (props = {}) => new Wrap([[Delay, props]])
};

// src/DevMode.tsx
var DevMode = (props) => null;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ClientOnly,
  DefaultProps,
  DefaultPropsProvider,
  Delay,
  DevMode,
  ErrorBoundary,
  ErrorBoundaryGroup,
  Suspense,
  Suspensive,
  SuspensiveProvider,
  useErrorBoundary,
  useErrorBoundaryFallbackProps,
  useErrorBoundaryGroup,
  wrap
});
//# sourceMappingURL=index.cjs.map