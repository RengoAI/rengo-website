"use client"
"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ErrorBoundary.tsx
var ErrorBoundary_exports = {};
__export(ErrorBoundary_exports, {
  ErrorBoundary: () => ErrorBoundary,
  useErrorBoundary: () => useErrorBoundary,
  useErrorBoundaryFallbackProps: () => useErrorBoundaryFallbackProps
});
module.exports = __toCommonJS(ErrorBoundary_exports);
var import_react3 = require("react");

// src/ErrorBoundaryGroup.tsx
var import_react2 = require("react");

// src/hooks/usePrevious.ts
var import_react = require("react");
var usePrevious = (value) => {
  const ref = (0, import_react.useRef)(value);
  (0, import_react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
};

// src/hooks/useIsChanged.ts
var useIsChanged = (value) => usePrevious(value) !== value;

// src/models/SuspensiveError.ts
var SuspensiveError = class _SuspensiveError extends Error {
  static assert(condition, message) {
    if (!condition) {
      throw new _SuspensiveError(message);
    }
  }
};
var Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children = "useErrorBoundary: this hook should be called in ErrorBoundary.props.children";
var Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback = "useErrorBoundaryFallbackProps: this hook should be called in ErrorBoundary.props.fallback";
var Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children = "useErrorBoundaryGroup: this hook should be called in ErrorBoundary.props.children";

// src/utils/hasResetKeysChanged.ts
var hasResetKeysChanged = (a = [], b = []) => a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));

// src/utils/increase.ts
var increase = (prev) => prev + 1;

// src/ErrorBoundaryGroup.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var ErrorBoundaryGroupContext = (0, import_react2.createContext)(void 0);
if (process.env.NODE_ENV === "development") {
  ErrorBoundaryGroupContext.displayName = "ErrorBoundaryGroupContext";
}
var ErrorBoundaryGroup = Object.assign(
  (() => {
    const ErrorBoundaryGroup2 = ({ blockOutside = false, children }) => {
      const [resetKey, reset] = (0, import_react2.useReducer)(increase, 0);
      const parentGroup = (0, import_react2.useContext)(ErrorBoundaryGroupContext);
      const isParentGroupResetKeyChanged = useIsChanged(parentGroup == null ? void 0 : parentGroup.resetKey);
      (0, import_react2.useEffect)(() => {
        if (!blockOutside && isParentGroupResetKeyChanged) {
          reset();
        }
      }, [isParentGroupResetKeyChanged, blockOutside]);
      const value = (0, import_react2.useMemo)(() => ({ reset, resetKey }), [resetKey]);
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ErrorBoundaryGroupContext.Provider, { value, children });
    };
    if (process.env.NODE_ENV === "development") {
      ErrorBoundaryGroup2.displayName = "ErrorBoundaryGroup";
    }
    return ErrorBoundaryGroup2;
  })(),
  {
    Consumer: ({
      children
    }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children(useErrorBoundaryGroup()) })
  }
);
var useErrorBoundaryGroup = () => {
  const group = (0, import_react2.useContext)(ErrorBoundaryGroupContext);
  SuspensiveError.assert(
    group != null,
    Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children
  );
  return (0, import_react2.useMemo)(
    () => ({
      /**
       * When you want to reset multiple ErrorBoundaries as children of ErrorBoundaryGroup, You can use this reset
       */
      reset: group.reset
    }),
    [group.reset]
  );
};

// src/ErrorBoundary.tsx
var import_jsx_runtime2 = require("react/jsx-runtime");
var checkErrorBoundary = (shouldCatch, error) => {
  if (typeof shouldCatch === "boolean") {
    return shouldCatch;
  }
  if (shouldCatch.prototype instanceof Error) {
    return error instanceof shouldCatch;
  }
  return shouldCatch(error);
};
var initialErrorBoundaryState = {
  isError: false,
  error: null
};
var BaseErrorBoundary = class extends import_react3.Component {
  constructor() {
    super(...arguments);
    this.state = initialErrorBoundaryState;
    this.reset = () => {
      var _a, _b;
      (_b = (_a = this.props).onReset) == null ? void 0 : _b.call(_a);
      this.setState(initialErrorBoundaryState);
    };
  }
  static getDerivedStateFromError(error) {
    return { isError: true, error };
  }
  componentDidUpdate(prevProps, prevState) {
    const { isError } = this.state;
    const { resetKeys } = this.props;
    if (isError && prevState.isError && hasResetKeysChanged(prevProps.resetKeys, resetKeys)) {
      this.reset();
    }
  }
  componentDidCatch(error, info) {
    var _a, _b;
    (_b = (_a = this.props).onError) == null ? void 0 : _b.call(_a, error, info);
  }
  render() {
    const { children, fallback, shouldCatch = true } = this.props;
    const { isError, error } = this.state;
    let childrenOrFallback = children;
    if (isError) {
      if (error instanceof SuspensiveError) {
        throw error;
      }
      const isCatch = Array.isArray(shouldCatch) ? shouldCatch.some((shouldCatch2) => checkErrorBoundary(shouldCatch2, error)) : checkErrorBoundary(shouldCatch, error);
      if (!isCatch) {
        throw error;
      }
      if (typeof fallback === "undefined") {
        if (process.env.NODE_ENV === "development") {
          console.error("ErrorBoundary of @suspensive/react requires a defined fallback");
        }
        throw error;
      }
      if (typeof fallback === "function") {
        const FallbackComponent = fallback;
        childrenOrFallback = /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(FallbackComponent, { error, reset: this.reset });
      } else {
        childrenOrFallback = fallback;
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(ErrorBoundaryContext.Provider, { value: __spreadProps(__spreadValues({}, this.state), { reset: this.reset }), children: childrenOrFallback });
  }
};
var ErrorBoundary = Object.assign(
  (() => {
    const ErrorBoundary2 = (0, import_react3.forwardRef)(
      // TODO: remove this line
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ({ fallback, children, onError, onReset, resetKeys, shouldCatch }, ref) => {
        var _a;
        const group = (_a = (0, import_react3.useContext)(ErrorBoundaryGroupContext)) != null ? _a : { resetKey: 0 };
        const baseErrorBoundaryRef = (0, import_react3.useRef)(null);
        (0, import_react3.useImperativeHandle)(ref, () => ({
          reset: () => {
            var _a2;
            return (_a2 = baseErrorBoundaryRef.current) == null ? void 0 : _a2.reset();
          }
        }));
        return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
          BaseErrorBoundary,
          {
            shouldCatch,
            fallback,
            onError,
            onReset,
            resetKeys: [group.resetKey, ...resetKeys || []],
            ref: baseErrorBoundaryRef,
            children
          }
        );
      }
    );
    if (process.env.NODE_ENV === "development") {
      ErrorBoundary2.displayName = "ErrorBoundary";
    }
    return ErrorBoundary2;
  })(),
  {
    Consumer: ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: children(useErrorBoundary()) })
  }
);
var ErrorBoundaryContext = (0, import_react3.createContext)(null);
if (process.env.NODE_ENV === "development") {
  ErrorBoundaryContext.displayName = "ErrorBoundaryContext";
}
var useErrorBoundary = () => {
  const [state, setState] = (0, import_react3.useState)({
    isError: false,
    error: null
  });
  if (state.isError) {
    throw state.error;
  }
  const errorBoundary = (0, import_react3.useContext)(ErrorBoundaryContext);
  SuspensiveError.assert(
    errorBoundary != null && !errorBoundary.isError,
    Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children
  );
  return (0, import_react3.useMemo)(
    () => ({
      setError: (error) => setState({ isError: true, error })
    }),
    []
  );
};
var useErrorBoundaryFallbackProps = () => {
  const errorBoundary = (0, import_react3.useContext)(ErrorBoundaryContext);
  SuspensiveError.assert(
    errorBoundary != null && errorBoundary.isError,
    Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback
  );
  return (0, import_react3.useMemo)(
    () => ({
      error: errorBoundary.error,
      reset: errorBoundary.reset
    }),
    [errorBoundary.error, errorBoundary.reset]
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ErrorBoundary,
  useErrorBoundary,
  useErrorBoundaryFallbackProps
});
//# sourceMappingURL=ErrorBoundary.cjs.map