{"version":3,"sources":["../src/ErrorBoundary.tsx","../src/ErrorBoundaryGroup.tsx","../src/hooks/usePrevious.ts","../src/hooks/useIsChanged.ts","../src/models/SuspensiveError.ts","../src/utils/hasResetKeysChanged.ts","../src/utils/increase.ts"],"sourcesContent":["import {\n  Component,\n  type ErrorInfo,\n  type FunctionComponent,\n  type PropsWithChildren,\n  type ReactNode,\n  createContext,\n  forwardRef,\n  useContext,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport type { PropsWithDevMode } from './DevMode'\nimport { ErrorBoundaryGroupContext } from './ErrorBoundaryGroup'\nimport {\n  Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback,\n  Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children,\n  SuspensiveError,\n} from './models/SuspensiveError'\nimport type { ConstructorType } from './utility-types'\nimport { hasResetKeysChanged } from './utils'\n\nexport interface ErrorBoundaryFallbackProps<TError extends Error = Error> {\n  /**\n   * when ErrorBoundary catch error, you can use this error\n   */\n  error: TError\n  /**\n   * when you want to reset caught error, you can use this reset\n   */\n  reset: () => void\n}\n\ntype ShouldCatchCallback = (error: Error) => boolean\ntype ShouldCatch = ConstructorType<Error> | ShouldCatchCallback | boolean\nconst checkErrorBoundary = (shouldCatch: ShouldCatch, error: Error) => {\n  if (typeof shouldCatch === 'boolean') {\n    return shouldCatch\n  }\n  if (shouldCatch.prototype instanceof Error) {\n    return error instanceof shouldCatch\n  }\n  return (shouldCatch as ShouldCatchCallback)(error)\n}\n\nexport type ErrorBoundaryProps = PropsWithDevMode<\n  PropsWithChildren<{\n    /**\n     * an array of elements for the ErrorBoundary to check each render. If any of those elements change between renders, then the ErrorBoundary will reset the state which will re-render the children\n     */\n    resetKeys?: unknown[]\n    /**\n     * when ErrorBoundary is reset by resetKeys or fallback's props.reset, onReset will be triggered\n     */\n    onReset?(): void\n    /**\n     * when ErrorBoundary catch error, onError will be triggered\n     */\n    onError?(error: Error, info: ErrorInfo): void\n    /**\n     * when ErrorBoundary catch error, fallback will be render instead of children\n     */\n    fallback: ReactNode | FunctionComponent<ErrorBoundaryFallbackProps>\n    /**\n     * determines whether the ErrorBoundary should catch errors based on conditions\n     * @default true\n     */\n    shouldCatch?: ShouldCatch | [ShouldCatch, ...ShouldCatch[]]\n  }>,\n  {\n    /**\n     * @deprecated Use official react devtools instead\n     * @see https://react.dev/learn/react-developer-tools\n     */\n    showFallback?:\n      | boolean\n      | {\n          /**\n           * @deprecated Use official react devtools instead\n           * @see https://react.dev/learn/react-developer-tools\n           */\n          errorMessage?: string\n          /**\n           * @deprecated Use official react devtools instead\n           * @see https://react.dev/learn/react-developer-tools\n           */\n          after?: number\n        }\n  }\n>\n\ntype ErrorBoundaryState<TError extends Error = Error> =\n  | { isError: true; error: TError }\n  | { isError: false; error: null }\n\nconst initialErrorBoundaryState: ErrorBoundaryState = {\n  isError: false,\n  error: null,\n}\nclass BaseErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { isError: true, error }\n  }\n\n  state = initialErrorBoundaryState\n\n  componentDidUpdate(prevProps: ErrorBoundaryProps, prevState: ErrorBoundaryState) {\n    const { isError } = this.state\n    const { resetKeys } = this.props\n    if (isError && prevState.isError && hasResetKeysChanged(prevProps.resetKeys, resetKeys)) {\n      this.reset()\n    }\n  }\n\n  componentDidCatch(error: Error, info: ErrorInfo) {\n    this.props.onError?.(error, info)\n  }\n\n  reset = () => {\n    this.props.onReset?.()\n    this.setState(initialErrorBoundaryState)\n  }\n\n  render() {\n    const { children, fallback, shouldCatch = true } = this.props\n    const { isError, error } = this.state\n\n    let childrenOrFallback = children\n\n    if (isError) {\n      if (error instanceof SuspensiveError) {\n        throw error\n      }\n      const isCatch = Array.isArray(shouldCatch)\n        ? shouldCatch.some((shouldCatch) => checkErrorBoundary(shouldCatch, error))\n        : checkErrorBoundary(shouldCatch, error)\n      if (!isCatch) {\n        throw error\n      }\n\n      if (typeof fallback === 'undefined') {\n        if (process.env.NODE_ENV === 'development') {\n          console.error('ErrorBoundary of @suspensive/react requires a defined fallback')\n        }\n        throw error\n      }\n\n      if (typeof fallback === 'function') {\n        const FallbackComponent = fallback\n        childrenOrFallback = <FallbackComponent error={error} reset={this.reset} />\n      } else {\n        childrenOrFallback = fallback\n      }\n    }\n\n    return (\n      <ErrorBoundaryContext.Provider value={{ ...this.state, reset: this.reset }}>\n        {childrenOrFallback}\n      </ErrorBoundaryContext.Provider>\n    )\n  }\n}\n\n/**\n * This component provides a simple and reusable wrapper that you can use to wrap around your components. Any rendering errors in your components hierarchy can then be gracefully handled.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundary Suspensive Docs}\n */\nexport const ErrorBoundary = Object.assign(\n  (() => {\n    const ErrorBoundary = forwardRef<{ reset(): void }, ErrorBoundaryProps>(\n      // TODO: remove this line\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      ({ fallback, children, onError, onReset, resetKeys, shouldCatch }, ref) => {\n        const group = useContext(ErrorBoundaryGroupContext) ?? { resetKey: 0 }\n        const baseErrorBoundaryRef = useRef<BaseErrorBoundary>(null)\n        useImperativeHandle(ref, () => ({\n          reset: () => baseErrorBoundaryRef.current?.reset(),\n        }))\n\n        return (\n          <BaseErrorBoundary\n            shouldCatch={shouldCatch}\n            fallback={fallback}\n            onError={onError}\n            onReset={onReset}\n            resetKeys={[group.resetKey, ...(resetKeys || [])]}\n            ref={baseErrorBoundaryRef}\n          >\n            {children}\n          </BaseErrorBoundary>\n        )\n      }\n    )\n\n    if (process.env.NODE_ENV === 'development') {\n      ErrorBoundary.displayName = 'ErrorBoundary'\n    }\n\n    return ErrorBoundary\n  })(),\n  {\n    Consumer: ({ children }: { children: (errorBoundary: ReturnType<typeof useErrorBoundary>) => ReactNode }) => (\n      <>{children(useErrorBoundary())}</>\n    ),\n  }\n)\n\nconst ErrorBoundaryContext = createContext<({ reset: () => void } & ErrorBoundaryState) | null>(null)\nif (process.env.NODE_ENV === 'development') {\n  ErrorBoundaryContext.displayName = 'ErrorBoundaryContext'\n}\n\n/**\n * This hook provides a simple and reusable wrapper that you can use to wrap around your components. Any rendering errors in your components hierarchy can then be gracefully handled.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundary#useerrorboundary Suspensive Docs}\n */\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport const useErrorBoundary = <TError extends Error = Error>() => {\n  const [state, setState] = useState<ErrorBoundaryState<TError>>({\n    isError: false,\n    error: null,\n  })\n  if (state.isError) {\n    throw state.error\n  }\n\n  const errorBoundary = useContext(ErrorBoundaryContext)\n  SuspensiveError.assert(\n    errorBoundary != null && !errorBoundary.isError,\n    Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children\n  )\n\n  return useMemo(\n    () => ({\n      setError: (error: TError) => setState({ isError: true, error }),\n    }),\n    []\n  )\n}\n\n/**\n * This hook allows you to access the reset method and error objects without prop drilling.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundary#useerrorboundaryfallbackprops Suspensive Docs}\n */\nexport const useErrorBoundaryFallbackProps = <TError extends Error = Error>(): ErrorBoundaryFallbackProps<TError> => {\n  const errorBoundary = useContext(ErrorBoundaryContext)\n  SuspensiveError.assert(\n    errorBoundary != null && errorBoundary.isError,\n    Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback\n  )\n\n  return useMemo(\n    () => ({\n      error: errorBoundary.error as TError,\n      reset: errorBoundary.reset,\n    }),\n    [errorBoundary.error, errorBoundary.reset]\n  )\n}\n","import {\n  type PropsWithChildren,\n  type ReactNode,\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n} from 'react'\nimport { useIsChanged } from './hooks'\nimport {\n  Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children,\n  SuspensiveError,\n} from './models/SuspensiveError'\nimport { increase } from './utils'\n\nexport const ErrorBoundaryGroupContext = createContext<{ reset: () => void; resetKey: number } | undefined>(undefined)\nif (process.env.NODE_ENV === 'development') {\n  ErrorBoundaryGroupContext.displayName = 'ErrorBoundaryGroupContext'\n}\n\nexport interface ErrorBoundaryGroupProps extends PropsWithChildren {\n  /**\n   * If you use blockOutside as true, ErrorBoundaryGroup will protect multiple ErrorBoundaries as its children from external ErrorBoundaryGroup's resetKey\n   * @default false\n   */\n  blockOutside?: boolean\n}\n\n/**\n * ErrorBoundaryGroup is a wrapper component that allows you to manage multiple ErrorBoundaries easily.\n * ErrorBoundaries as children of nested ErrorBoundaryGroup will also be reset by parent ErrorBoundaryGroup.Consumer.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundaryGroup Suspensive Docs}\n */\nexport const ErrorBoundaryGroup = Object.assign(\n  (() => {\n    const ErrorBoundaryGroup = ({ blockOutside = false, children }: ErrorBoundaryGroupProps) => {\n      const [resetKey, reset] = useReducer(increase, 0)\n      const parentGroup = useContext(ErrorBoundaryGroupContext)\n      const isParentGroupResetKeyChanged = useIsChanged(parentGroup?.resetKey)\n\n      useEffect(() => {\n        if (!blockOutside && isParentGroupResetKeyChanged) {\n          reset()\n        }\n      }, [isParentGroupResetKeyChanged, blockOutside])\n\n      const value = useMemo(() => ({ reset, resetKey }), [resetKey])\n\n      return <ErrorBoundaryGroupContext.Provider value={value}>{children}</ErrorBoundaryGroupContext.Provider>\n    }\n    if (process.env.NODE_ENV === 'development') {\n      ErrorBoundaryGroup.displayName = 'ErrorBoundaryGroup'\n    }\n\n    return ErrorBoundaryGroup\n  })(),\n  {\n    Consumer: ({\n      children,\n    }: {\n      children: (errorBoundaryGroup: ReturnType<typeof useErrorBoundaryGroup>) => ReactNode\n    }) => <>{children(useErrorBoundaryGroup())}</>,\n  }\n)\n\n/**\n * This hook provides the reset method for the ErrorBoundaryGroup.\n * Must be used within an ErrorBoundaryGroup component.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundaryGroup#useerrorboundarygroup Suspensive Docs}\n */\nexport const useErrorBoundaryGroup = (): { reset: () => void } => {\n  const group = useContext(ErrorBoundaryGroupContext)\n  SuspensiveError.assert(\n    group != null,\n    Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children\n  )\n  return useMemo(\n    () => ({\n      /**\n       * When you want to reset multiple ErrorBoundaries as children of ErrorBoundaryGroup, You can use this reset\n       */\n      reset: group.reset,\n    }),\n    [group.reset]\n  )\n}\n","import { useEffect, useRef } from 'react'\n\nexport const usePrevious = <TValue>(value: TValue): TValue => {\n  const ref = useRef<TValue>(value)\n\n  useEffect(() => {\n    ref.current = value\n  }, [value])\n\n  return ref.current\n}\n","import { usePrevious } from './usePrevious'\n\nexport const useIsChanged = (value: unknown) => usePrevious(value) !== value\n","export class SuspensiveError extends Error {\n  static assert(condition: boolean, message: string): asserts condition {\n    if (!condition) {\n      throw new SuspensiveError(message)\n    }\n  }\n}\n\nexport const Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children =\n  'useErrorBoundary: this hook should be called in ErrorBoundary.props.children'\n\nexport const Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback =\n  'useErrorBoundaryFallbackProps: this hook should be called in ErrorBoundary.props.fallback'\n\nexport const Message_useErrorBoundaryGroup_this_hook_should_be_called_in_ErrorBoundary_props_children =\n  'useErrorBoundaryGroup: this hook should be called in ErrorBoundary.props.children'\n\nexport const Message_Delay_ms_prop_should_be_greater_than_or_equal_to_0 =\n  'Delay: ms prop should be greater than or equal to 0'\n\nexport const Message_DefaultProp_delay_ms_should_be_greater_than_0 = 'DefaultProps: delay.ms should be greater than 0'\n","export const hasResetKeysChanged = (a: unknown[] = [], b: unknown[] = []) =>\n  a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]))\n","export const increase = (prev: number) => prev + 1\n"],"mappings":"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","names":["import_react","import_react","ErrorBoundaryGroup","import_jsx_runtime","shouldCatch","ErrorBoundary","_a"]}