{"version":3,"sources":["../src/ErrorBoundary.tsx"],"sourcesContent":["import {\n  Component,\n  type ErrorInfo,\n  type FunctionComponent,\n  type PropsWithChildren,\n  type ReactNode,\n  createContext,\n  forwardRef,\n  useContext,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport type { PropsWithDevMode } from './DevMode'\nimport { ErrorBoundaryGroupContext } from './ErrorBoundaryGroup'\nimport {\n  Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback,\n  Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children,\n  SuspensiveError,\n} from './models/SuspensiveError'\nimport type { ConstructorType } from './utility-types'\nimport { hasResetKeysChanged } from './utils'\n\nexport interface ErrorBoundaryFallbackProps<TError extends Error = Error> {\n  /**\n   * when ErrorBoundary catch error, you can use this error\n   */\n  error: TError\n  /**\n   * when you want to reset caught error, you can use this reset\n   */\n  reset: () => void\n}\n\ntype ShouldCatchCallback = (error: Error) => boolean\ntype ShouldCatch = ConstructorType<Error> | ShouldCatchCallback | boolean\nconst checkErrorBoundary = (shouldCatch: ShouldCatch, error: Error) => {\n  if (typeof shouldCatch === 'boolean') {\n    return shouldCatch\n  }\n  if (shouldCatch.prototype instanceof Error) {\n    return error instanceof shouldCatch\n  }\n  return (shouldCatch as ShouldCatchCallback)(error)\n}\n\nexport type ErrorBoundaryProps = PropsWithDevMode<\n  PropsWithChildren<{\n    /**\n     * an array of elements for the ErrorBoundary to check each render. If any of those elements change between renders, then the ErrorBoundary will reset the state which will re-render the children\n     */\n    resetKeys?: unknown[]\n    /**\n     * when ErrorBoundary is reset by resetKeys or fallback's props.reset, onReset will be triggered\n     */\n    onReset?(): void\n    /**\n     * when ErrorBoundary catch error, onError will be triggered\n     */\n    onError?(error: Error, info: ErrorInfo): void\n    /**\n     * when ErrorBoundary catch error, fallback will be render instead of children\n     */\n    fallback: ReactNode | FunctionComponent<ErrorBoundaryFallbackProps>\n    /**\n     * determines whether the ErrorBoundary should catch errors based on conditions\n     * @default true\n     */\n    shouldCatch?: ShouldCatch | [ShouldCatch, ...ShouldCatch[]]\n  }>,\n  {\n    /**\n     * @deprecated Use official react devtools instead\n     * @see https://react.dev/learn/react-developer-tools\n     */\n    showFallback?:\n      | boolean\n      | {\n          /**\n           * @deprecated Use official react devtools instead\n           * @see https://react.dev/learn/react-developer-tools\n           */\n          errorMessage?: string\n          /**\n           * @deprecated Use official react devtools instead\n           * @see https://react.dev/learn/react-developer-tools\n           */\n          after?: number\n        }\n  }\n>\n\ntype ErrorBoundaryState<TError extends Error = Error> =\n  | { isError: true; error: TError }\n  | { isError: false; error: null }\n\nconst initialErrorBoundaryState: ErrorBoundaryState = {\n  isError: false,\n  error: null,\n}\nclass BaseErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { isError: true, error }\n  }\n\n  state = initialErrorBoundaryState\n\n  componentDidUpdate(prevProps: ErrorBoundaryProps, prevState: ErrorBoundaryState) {\n    const { isError } = this.state\n    const { resetKeys } = this.props\n    if (isError && prevState.isError && hasResetKeysChanged(prevProps.resetKeys, resetKeys)) {\n      this.reset()\n    }\n  }\n\n  componentDidCatch(error: Error, info: ErrorInfo) {\n    this.props.onError?.(error, info)\n  }\n\n  reset = () => {\n    this.props.onReset?.()\n    this.setState(initialErrorBoundaryState)\n  }\n\n  render() {\n    const { children, fallback, shouldCatch = true } = this.props\n    const { isError, error } = this.state\n\n    let childrenOrFallback = children\n\n    if (isError) {\n      if (error instanceof SuspensiveError) {\n        throw error\n      }\n      const isCatch = Array.isArray(shouldCatch)\n        ? shouldCatch.some((shouldCatch) => checkErrorBoundary(shouldCatch, error))\n        : checkErrorBoundary(shouldCatch, error)\n      if (!isCatch) {\n        throw error\n      }\n\n      if (typeof fallback === 'undefined') {\n        if (process.env.NODE_ENV === 'development') {\n          console.error('ErrorBoundary of @suspensive/react requires a defined fallback')\n        }\n        throw error\n      }\n\n      if (typeof fallback === 'function') {\n        const FallbackComponent = fallback\n        childrenOrFallback = <FallbackComponent error={error} reset={this.reset} />\n      } else {\n        childrenOrFallback = fallback\n      }\n    }\n\n    return (\n      <ErrorBoundaryContext.Provider value={{ ...this.state, reset: this.reset }}>\n        {childrenOrFallback}\n      </ErrorBoundaryContext.Provider>\n    )\n  }\n}\n\n/**\n * This component provides a simple and reusable wrapper that you can use to wrap around your components. Any rendering errors in your components hierarchy can then be gracefully handled.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundary Suspensive Docs}\n */\nexport const ErrorBoundary = Object.assign(\n  (() => {\n    const ErrorBoundary = forwardRef<{ reset(): void }, ErrorBoundaryProps>(\n      // TODO: remove this line\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      ({ fallback, children, onError, onReset, resetKeys, shouldCatch }, ref) => {\n        const group = useContext(ErrorBoundaryGroupContext) ?? { resetKey: 0 }\n        const baseErrorBoundaryRef = useRef<BaseErrorBoundary>(null)\n        useImperativeHandle(ref, () => ({\n          reset: () => baseErrorBoundaryRef.current?.reset(),\n        }))\n\n        return (\n          <BaseErrorBoundary\n            shouldCatch={shouldCatch}\n            fallback={fallback}\n            onError={onError}\n            onReset={onReset}\n            resetKeys={[group.resetKey, ...(resetKeys || [])]}\n            ref={baseErrorBoundaryRef}\n          >\n            {children}\n          </BaseErrorBoundary>\n        )\n      }\n    )\n\n    if (process.env.NODE_ENV === 'development') {\n      ErrorBoundary.displayName = 'ErrorBoundary'\n    }\n\n    return ErrorBoundary\n  })(),\n  {\n    Consumer: ({ children }: { children: (errorBoundary: ReturnType<typeof useErrorBoundary>) => ReactNode }) => (\n      <>{children(useErrorBoundary())}</>\n    ),\n  }\n)\n\nconst ErrorBoundaryContext = createContext<({ reset: () => void } & ErrorBoundaryState) | null>(null)\nif (process.env.NODE_ENV === 'development') {\n  ErrorBoundaryContext.displayName = 'ErrorBoundaryContext'\n}\n\n/**\n * This hook provides a simple and reusable wrapper that you can use to wrap around your components. Any rendering errors in your components hierarchy can then be gracefully handled.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundary#useerrorboundary Suspensive Docs}\n */\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport const useErrorBoundary = <TError extends Error = Error>() => {\n  const [state, setState] = useState<ErrorBoundaryState<TError>>({\n    isError: false,\n    error: null,\n  })\n  if (state.isError) {\n    throw state.error\n  }\n\n  const errorBoundary = useContext(ErrorBoundaryContext)\n  SuspensiveError.assert(\n    errorBoundary != null && !errorBoundary.isError,\n    Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children\n  )\n\n  return useMemo(\n    () => ({\n      setError: (error: TError) => setState({ isError: true, error }),\n    }),\n    []\n  )\n}\n\n/**\n * This hook allows you to access the reset method and error objects without prop drilling.\n * @see {@link https://suspensive.org/docs/react/ErrorBoundary#useerrorboundaryfallbackprops Suspensive Docs}\n */\nexport const useErrorBoundaryFallbackProps = <TError extends Error = Error>(): ErrorBoundaryFallbackProps<TError> => {\n  const errorBoundary = useContext(ErrorBoundaryContext)\n  SuspensiveError.assert(\n    errorBoundary != null && errorBoundary.isError,\n    Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback\n  )\n\n  return useMemo(\n    () => ({\n      error: errorBoundary.error as TError,\n      reset: errorBoundary.reset,\n    }),\n    [errorBoundary.error, errorBoundary.reset]\n  )\n}\n"],"mappings":"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","names":["shouldCatch","ErrorBoundary","_a"]}