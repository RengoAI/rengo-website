"use client"
import {
  ErrorBoundaryGroupContext
} from "./chunk-S5J6B5JD.js";
import {
  hasResetKeysChanged
} from "./chunk-ZJULBOVW.js";
import {
  Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback,
  Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children,
  SuspensiveError
} from "./chunk-NF2UFYHD.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-HVDFXOFP.js";

// src/ErrorBoundary.tsx
import {
  Component,
  createContext,
  forwardRef,
  useContext,
  useImperativeHandle,
  useMemo,
  useRef,
  useState
} from "react";
import { Fragment, jsx } from "react/jsx-runtime";
var checkErrorBoundary = (shouldCatch, error) => {
  if (typeof shouldCatch === "boolean") {
    return shouldCatch;
  }
  if (shouldCatch.prototype instanceof Error) {
    return error instanceof shouldCatch;
  }
  return shouldCatch(error);
};
var initialErrorBoundaryState = {
  isError: false,
  error: null
};
var BaseErrorBoundary = class extends Component {
  constructor() {
    super(...arguments);
    this.state = initialErrorBoundaryState;
    this.reset = () => {
      var _a, _b;
      (_b = (_a = this.props).onReset) == null ? void 0 : _b.call(_a);
      this.setState(initialErrorBoundaryState);
    };
  }
  static getDerivedStateFromError(error) {
    return { isError: true, error };
  }
  componentDidUpdate(prevProps, prevState) {
    const { isError } = this.state;
    const { resetKeys } = this.props;
    if (isError && prevState.isError && hasResetKeysChanged(prevProps.resetKeys, resetKeys)) {
      this.reset();
    }
  }
  componentDidCatch(error, info) {
    var _a, _b;
    (_b = (_a = this.props).onError) == null ? void 0 : _b.call(_a, error, info);
  }
  render() {
    const { children, fallback, shouldCatch = true } = this.props;
    const { isError, error } = this.state;
    let childrenOrFallback = children;
    if (isError) {
      if (error instanceof SuspensiveError) {
        throw error;
      }
      const isCatch = Array.isArray(shouldCatch) ? shouldCatch.some((shouldCatch2) => checkErrorBoundary(shouldCatch2, error)) : checkErrorBoundary(shouldCatch, error);
      if (!isCatch) {
        throw error;
      }
      if (typeof fallback === "undefined") {
        if (process.env.NODE_ENV === "development") {
          console.error("ErrorBoundary of @suspensive/react requires a defined fallback");
        }
        throw error;
      }
      if (typeof fallback === "function") {
        const FallbackComponent = fallback;
        childrenOrFallback = /* @__PURE__ */ jsx(FallbackComponent, { error, reset: this.reset });
      } else {
        childrenOrFallback = fallback;
      }
    }
    return /* @__PURE__ */ jsx(ErrorBoundaryContext.Provider, { value: __spreadProps(__spreadValues({}, this.state), { reset: this.reset }), children: childrenOrFallback });
  }
};
var ErrorBoundary = Object.assign(
  (() => {
    const ErrorBoundary2 = forwardRef(
      // TODO: remove this line
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ({ fallback, children, onError, onReset, resetKeys, shouldCatch }, ref) => {
        var _a;
        const group = (_a = useContext(ErrorBoundaryGroupContext)) != null ? _a : { resetKey: 0 };
        const baseErrorBoundaryRef = useRef(null);
        useImperativeHandle(ref, () => ({
          reset: () => {
            var _a2;
            return (_a2 = baseErrorBoundaryRef.current) == null ? void 0 : _a2.reset();
          }
        }));
        return /* @__PURE__ */ jsx(
          BaseErrorBoundary,
          {
            shouldCatch,
            fallback,
            onError,
            onReset,
            resetKeys: [group.resetKey, ...resetKeys || []],
            ref: baseErrorBoundaryRef,
            children
          }
        );
      }
    );
    if (process.env.NODE_ENV === "development") {
      ErrorBoundary2.displayName = "ErrorBoundary";
    }
    return ErrorBoundary2;
  })(),
  {
    Consumer: ({ children }) => /* @__PURE__ */ jsx(Fragment, { children: children(useErrorBoundary()) })
  }
);
var ErrorBoundaryContext = createContext(null);
if (process.env.NODE_ENV === "development") {
  ErrorBoundaryContext.displayName = "ErrorBoundaryContext";
}
var useErrorBoundary = () => {
  const [state, setState] = useState({
    isError: false,
    error: null
  });
  if (state.isError) {
    throw state.error;
  }
  const errorBoundary = useContext(ErrorBoundaryContext);
  SuspensiveError.assert(
    errorBoundary != null && !errorBoundary.isError,
    Message_useErrorBoundary_this_hook_should_be_called_in_ErrorBoundary_props_children
  );
  return useMemo(
    () => ({
      setError: (error) => setState({ isError: true, error })
    }),
    []
  );
};
var useErrorBoundaryFallbackProps = () => {
  const errorBoundary = useContext(ErrorBoundaryContext);
  SuspensiveError.assert(
    errorBoundary != null && errorBoundary.isError,
    Message_useErrorBoundaryFallbackProps_this_hook_should_be_called_in_ErrorBoundary_props_fallback
  );
  return useMemo(
    () => ({
      error: errorBoundary.error,
      reset: errorBoundary.reset
    }),
    [errorBoundary.error, errorBoundary.reset]
  );
};

export {
  ErrorBoundary,
  useErrorBoundary,
  useErrorBoundaryFallbackProps
};
//# sourceMappingURL=chunk-LVRP5XPR.js.map