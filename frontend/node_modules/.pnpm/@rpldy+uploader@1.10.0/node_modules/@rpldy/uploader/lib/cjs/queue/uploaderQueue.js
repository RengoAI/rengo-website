"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _shared = require("@rpldy/shared");
var _simpleState = _interopRequireDefault(require("@rpldy/simple-state"));
var _consts = require("../consts");
var _processQueueNext = _interopRequireDefault(require("./processQueueNext"));
var _processAbort = require("./processAbort");
var _batchHelpers = require("./batchHelpers");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const createUploaderQueue = (options, trigger, cancellable, sender, uploaderId) => {
  const {
    state,
    update
  } = (0, _simpleState.default)({
    itemQueue: {},
    batchQueue: [],
    currentBatch: null,
    batchesStartPending: [],
    batches: {},
    items: {},
    activeIds: [],
    aborts: {}
  });
  const getState = () => state;
  const updateState = updater => {
    update(updater);
  };
  const add = item => {
    if (state.items[item.id] && !item.recycled) {
      throw new Error(`Uploader queue conflict - item ${item.id} already exists`);
    }
    if (item.recycled) {
      (0, _batchHelpers.detachRecycledFromPreviousBatch)(queueState, item);
    }
    updateState(state => {
      state.items[item.id] = item;
    });
  };
  const handleItemProgress = (item, completed, loaded, total) => {
    if (state.items[item.id]) {
      updateState(state => {
        const stateItem = state.items[item.id];
        stateItem.loaded = loaded;
        stateItem.completed = completed;
        stateItem.total = total;
      });
      trigger(_consts.UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);
    }
  };
  sender.on(_consts.SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);
  sender.on(_consts.SENDER_EVENTS.BATCH_PROGRESS, batch => {
    const batchItems = state.batches[batch.id]?.batch.items;
    if (batchItems) {
      const [loaded, total] = batchItems.reduce((res, {
        id
      }) => {
        const {
          loaded,
          file
        } = state.items[id];
        const size = file?.size || loaded || 1;
        res[0] += loaded;
        res[1] += size;
        return res;
      }, [0, 0]);
      updateState(state => {
        const stateBatch = state.batches[batch.id].batch;
        stateBatch.total = total;
        stateBatch.loaded = loaded;
        stateBatch.completed = loaded / total;
      });
      (0, _batchHelpers.triggerUploaderBatchEvent)(queueState, batch.id, _consts.UPLOADER_EVENTS.BATCH_PROGRESS);
    }
  });
  const queueState = {
    uploaderId,
    getOptions: () => options,
    getCurrentActiveCount: () => state.activeIds.length,
    getState,
    updateState,
    trigger,
    runCancellable: (name, ...args) => {
      if (!(0, _shared.isFunction)(cancellable)) {
        throw new Error("Uploader queue - cancellable is of wrong type");
      }
      return cancellable(name, ...args);
    },
    sender,
    handleItemProgress,
    clearAllUploads: () => {
      queueState.updateState(state => {
        state.itemQueue = {};
        state.batchQueue = [];
        state.currentBatch = null;
        state.batches = {};
        state.items = {};
        state.activeIds = [];
      });
    },
    clearBatchUploads: batchId => {
      (0, _shared.scheduleIdleWork)(() => {
        _shared.logger.debugLog(`uploader.queue: started scheduled work to clear batch uploads (${batchId})`);
        if (getState().batches[batchId]) {
          (0, _batchHelpers.clearBatchData)(queueState, batchId);
        }
      });
    }
  };
  if ((0, _shared.hasWindow)() && _shared.logger.isDebugOn()) {
    window[`__rpldy_${uploaderId}_queue_state`] = queueState;
  }
  return {
    updateState,
    getState: queueState.getState,
    runCancellable: queueState.runCancellable,
    uploadBatch: (batch, batchOptions) => {
      if (batchOptions) {
        updateState(state => {
          state.batches[batch.id].batchOptions = batchOptions;
        });
      }
      (0, _processQueueNext.default)(queueState);
    },
    addBatch: (batch, batchOptions) => {
      updateState(state => {
        state.batches[batch.id] = {
          batch,
          batchOptions,
          itemBatchOptions: {},
          finishedCounter: 0
        };
        state.batchQueue.push(batch.id);
        state.itemQueue[batch.id] = batch.items.map(({
          id
        }) => id);
      });
      batch.items.forEach(add);
      return (0, _batchHelpers.getBatchFromState)(state, batch.id);
    },
    abortItem: (...args) => (0, _processAbort.processAbortItem)(queueState, ...args),
    abortBatch: (...args) => (0, _processAbort.processAbortBatch)(queueState, ...args),
    abortAll: (...args) => (0, _processAbort.processAbortAll)(queueState, ...args),
    clearPendingBatches: () => {
      (0, _batchHelpers.removePendingBatches)(queueState);
    },
    uploadPendingBatches: uploadOptions => {
      (0, _batchHelpers.preparePendingForUpload)(queueState, uploadOptions);
      (0, _processQueueNext.default)(queueState);
    },
    cancelBatch: batch => (0, _batchHelpers.cancelBatchWithId)(queueState, batch.id)
  };
};
var _default = exports.default = createUploaderQueue;