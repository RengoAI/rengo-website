"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNextIdGroup = exports.findNextItemIndex = exports.default = void 0;
var _shared = require("@rpldy/shared");
var _processBatchItems = _interopRequireDefault(require("./processBatchItems"));
var _batchHelpers = require("./batchHelpers");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const getIsItemInActiveRequest = (queue, itemId) => {
  return queue.getState().activeIds.flat().includes(itemId);
};
const getIsItemReady = item => item.state === _shared.FILE_STATES.ADDED;
const findNextItemIndex = queue => {
  const state = queue.getState(),
    itemQueue = state.itemQueue,
    items = state.items;
  let nextItemId = null,
    batchIndex = 0,
    itemIndex = 0,
    batchId = state.batchQueue[batchIndex];
  while (batchId && !nextItemId) {
    if ((0, _batchHelpers.getIsBatchReady)(queue, batchId)) {
      nextItemId = itemQueue[batchId][itemIndex];
      while (nextItemId && (getIsItemInActiveRequest(queue, nextItemId) || !getIsItemReady(items[nextItemId]))) {
        itemIndex += 1;
        nextItemId = itemQueue[batchId][itemIndex];
      }
    }
    if (!nextItemId) {
      batchIndex += 1;
      batchId = state.batchQueue[batchIndex];
      itemIndex = 0;
    }
  }
  return nextItemId ? [batchId, itemIndex] : null;
};
exports.findNextItemIndex = findNextItemIndex;
const getNextIdGroup = queue => {
  const state = queue.getState(),
    itemQueue = state.itemQueue,
    [nextBatchId, nextItemIndex] = findNextItemIndex(queue) || [];
  let nextId = nextBatchId && ~nextItemIndex ? itemQueue[nextBatchId][nextItemIndex] : null,
    nextGroup;
  if (nextId) {
    const {
        batchOptions
      } = state.batches[nextBatchId],
      groupMax = batchOptions.maxGroupSize || 0;
    if (batchOptions.grouped && groupMax > 1) {
      const batchItems = state.itemQueue[nextBatchId];
      nextGroup = batchItems.slice(nextItemIndex, nextItemIndex + groupMax);
    } else {
      nextGroup = [nextId];
    }
  }
  return nextGroup;
};
exports.getNextIdGroup = getNextIdGroup;
const updateItemsAsActive = (queue, ids) => {
  queue.updateState(state => {
    state.activeIds = state.activeIds.concat(ids);
  });
};
const processNextWithBatch = (queue, ids) => {
  let newBatchP;
  if (!(0, _batchHelpers.isItemBatchStartPending)(queue, ids[0])) {
    updateItemsAsActive(queue, ids);
    if ((0, _batchHelpers.isNewBatchStarting)(queue, ids[0])) {
      newBatchP = (0, _batchHelpers.loadNewBatchForItem)(queue, ids[0]).then(allowBatch => {
        let cancelled = !allowBatch;
        if (cancelled) {
          (0, _batchHelpers.cancelBatchForItem)(queue, ids[0]);
          processNext(queue);
        }
        return cancelled;
      }).catch(err => {
        _shared.logger.debugLog("uploader.processor: encountered error while preparing batch for request", err);
        (0, _batchHelpers.failBatchForItem)(queue, ids[0], err);
        processNext(queue);
        return true;
      });
    } else {
      newBatchP = Promise.resolve(false);
    }
  } else {
    newBatchP = Promise.resolve(true);
  }
  return newBatchP;
};
const processNext = queue => {
  let processPromise;
  const ids = getNextIdGroup(queue);
  if (ids) {
    const currentCount = queue.getCurrentActiveCount(),
      {
        concurrent = !!0,
        maxConcurrent = 0
      } = queue.getOptions();
    if (!currentCount || concurrent && currentCount < maxConcurrent) {
      _shared.logger.debugLog("uploader.processor: Processing next upload - ", {
        ids,
        currentCount
      });
      processPromise = processNextWithBatch(queue, ids).then(failedOrCancelled => {
        if (!failedOrCancelled) {
          (0, _processBatchItems.default)(queue, ids, processNext);
          if (concurrent) {
            processNext(queue);
          }
        }
      });
    }
  }
  return processPromise;
};
var _default = exports.default = processNext;