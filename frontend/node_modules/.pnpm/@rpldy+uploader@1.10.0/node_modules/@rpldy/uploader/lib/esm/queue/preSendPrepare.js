import { getMerge, isSamePropInArrays, logger, triggerUpdater } from "@rpldy/shared";
import { getIsItemFinalized } from "./itemHelpers";
const mergeWithUndefined = getMerge({
  undefinedOverwrites: true
});
const processPrepareResponse = (eventType, items, options, updated) => {
  let usedOptions = options,
    usedItems = items;
  if (updated && typeof updated !== "boolean") {
    logger.debugLog(`uploader.queue: REQUEST_PRE_SEND(${eventType}) event returned updated items/options`, updated);
    if (updated.items) {
      if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, ["id", "batchId", "recycled"])) {
        throw new Error(`REQUEST_PRE_SEND(${eventType}) event handlers must return same items with same ids`);
      }
      usedItems = updated.items;
    }
    if (updated.options) {
      usedOptions = mergeWithUndefined({}, options, updated.options);
    }
  }
  return {
    items: usedItems,
    options: usedOptions,
    cancelled: updated === false
  };
};
const triggerItemsPrepareEvent = (queue, eventSubject, items, options, eventType, validateResponse) => triggerUpdater(queue.trigger, eventType, eventSubject, options).then(updated => {
  validateResponse?.(updated);
  return processPrepareResponse(eventType, items, options, updated);
});
const persistPrepareResponse = (queue, prepared) => {
  const batchId = prepared.items[0].batchId;
  if (prepared.items[0] && queue.getState().batches[batchId]) {
    queue.updateState(state => {
      prepared.items.forEach(i => {
        if (!getIsItemFinalized(state.items[i.id])) {
          state.items[i.id] = i;
        }
      });
      const batchData = state.batches[batchId];
      prepared.items.forEach(({
        id
      }) => {
        batchData.itemBatchOptions[id] = prepared.options;
      });
    });
    const updatedState = queue.getState();
    prepared.items = prepared.items.map(item => updatedState.items[item.id]);
    const batchData = updatedState.batches[batchId];
    prepared.options = batchData.itemBatchOptions[prepared.items[0].id] || batchData.batchOptions;
  }
};
const prepareItems = (queue, subject, retrieveItemsFromSubject, createEventSubject, validateResponse, eventType) => {
  const items = retrieveItemsFromSubject(subject);
  const batchOptions = queue.getState().batches[items[0].batchId].batchOptions;
  const eventSubject = createEventSubject?.(subject, batchOptions) || subject;
  return triggerItemsPrepareEvent(queue, eventSubject, items, batchOptions, eventType, validateResponse).then(prepared => {
    if (!prepared.cancelled) {
      persistPrepareResponse(queue, prepared);
    }
    return prepared;
  });
};
const getItemsPrepareUpdater = (eventType, retrieveItemsFromSubject, createEventSubject = null, validateResponse = null) => (queue, subject) => prepareItems(queue, subject, retrieveItemsFromSubject, createEventSubject, validateResponse, eventType);
export { getItemsPrepareUpdater };