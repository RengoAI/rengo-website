"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _shared = require("@rpldy/shared");
var _defaults = require("./defaults");
var _utils = require("./utils");
let bCounter = 0;
const processFiles = (batchId, files, isPending, fileFilter) => {
  const all = fileFilter ? Array.prototype.map.call(files, f => (0, _shared.getIsBatchItem)(f) ? f.file || f.url : f) : [];
  return Promise.all(Array.prototype.map.call(files, (f, index) => {
    const filterResult = (fileFilter || _defaults.DEFAULT_FILTER)(all[index], index, all);
    return (0, _shared.isPromise)(filterResult) ? filterResult.then(result => !!result && f) : !!filterResult && f;
  })).then(filtered => filtered.filter(Boolean).map(f => (0, _shared.createBatchItem)(f, batchId, isPending)));
};
const createBatch = (files, uploaderId, options) => {
  bCounter += 1;
  const id = `batch-${bCounter}`;
  const isFileList = (0, _utils.getIsFileList)(files);
  const usedFiles = Array.isArray(files) || isFileList ? files : [files];
  const isPending = !options.autoUpload;
  return processFiles(id, usedFiles, isPending, options.fileFilter).then(items => {
    return {
      id,
      uploaderId,
      items,
      state: isPending ? _shared.BATCH_STATES.PENDING : _shared.BATCH_STATES.ADDED,
      completed: 0,
      loaded: 0,
      orgItemCount: items.length,
      additionalInfo: null
    };
  });
};
var _default = exports.default = createBatch;