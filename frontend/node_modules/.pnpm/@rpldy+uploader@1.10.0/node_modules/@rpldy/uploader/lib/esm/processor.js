import { logger } from "@rpldy/shared";
import { UPLOADER_EVENTS } from "./consts";
import createUploadQueue from "./queue";
import createItemsSender from "./batchItemsSender";
import createBatch from "./batch";
const createProcessor = (trigger, cancellable, options, uploaderId) => {
  const sender = createItemsSender(),
    queue = createUploadQueue(options, trigger, cancellable, sender, uploaderId);
  return {
    abortBatch: batchId => {
      queue.abortBatch(batchId);
    },
    abort: id => {
      if (id) {
        queue.abortItem(id);
      } else {
        queue.abortAll();
      }
    },
    addNewBatch: (files, processOptions) => createBatch(files, uploaderId, processOptions).then(batch => {
      let resultP;
      if (batch.items.length) {
        const addedBatch = queue.addBatch(batch, processOptions);
        resultP = queue.runCancellable(UPLOADER_EVENTS.BATCH_ADD, addedBatch, processOptions).then(isCancelled => {
          if (!isCancelled) {
            logger.debugLog(`uploady.uploader [${uploaderId}]: new items added - auto upload =
                       ${String(processOptions.autoUpload)}`, addedBatch.items);
            if (processOptions.autoUpload) {
              queue.uploadBatch(addedBatch);
            }
          } else {
            queue.cancelBatch(addedBatch);
          }
          return addedBatch;
        });
      } else {
        logger.debugLog(`uploady.uploader: no items to add. batch ${batch.id} is empty. check fileFilter if this isn't intended`);
      }
      return resultP || Promise.resolve(null);
    }),
    clearPendingBatches: () => {
      queue.clearPendingBatches();
    },
    processPendingBatches: uploadOptions => {
      queue.uploadPendingBatches(uploadOptions);
    }
  };
};
export default createProcessor;