"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lifeEvents = _interopRequireWildcard(require("@rpldy/life-events"));
var _shared = require("@rpldy/shared");
var _abort = _interopRequireDefault(require("@rpldy/abort"));
var _processor = _interopRequireDefault(require("./processor"));
var _consts = require("./consts");
var _utils = require("./utils");
var _composeEnhancers = _interopRequireDefault(require("./composeEnhancers"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const EVENT_NAMES = Object.values(_consts.UPLOADER_EVENTS);
const EXT_OUTSIDE_ENHANCER_TIME = "Uploady - uploader extensions can only be registered by enhancers",
  EXT_ALREADY_EXISTS = "Uploady - uploader extension by this name [%s] already exists";
let counter = 0;
const getComposedEnhancer = extEnhancer => (0, _composeEnhancers.default)((0, _abort.default)(), extEnhancer);
const getEnhancedUploader = (uploader, options, triggerWithUnwrap, setEnhancerTime) => {
  const enhancer = options.enhancer ? getComposedEnhancer(options.enhancer) : (0, _abort.default)();
  setEnhancerTime(true);
  const enhanced = enhancer(uploader, triggerWithUnwrap);
  setEnhancerTime(false);
  return enhanced || uploader;
};
const createUploader = options => {
  counter += 1;
  const uploaderId = `uploader-${counter}`;
  let enhancerTime = false;
  const extensions = {};
  _shared.logger.debugLog(`uploady.uploader: creating new instance (${uploaderId})`, {
    options,
    counter
  });
  let uploaderOptions = (0, _utils.getMandatoryOptions)(options);
  const clearPending = () => {
    processor.clearPendingBatches();
  };
  const getOptions = () => {
    return (0, _shared.clone)(uploaderOptions);
  };
  let {
    trigger,
    target: uploader
  } = (0, _lifeEvents.default)({
    id: uploaderId,
    update: updateOptions => {
      uploaderOptions = (0, _shared.merge)({}, uploaderOptions, updateOptions);
      return uploader;
    },
    add: (files, addOptions) => {
      const processOptions = (0, _shared.merge)({}, uploaderOptions, addOptions);
      if (processOptions.clearPendingOnAdd) {
        clearPending();
      }
      return processor.addNewBatch(files, processOptions).then(() => {
        _shared.logger.debugLog(`uploady.uploader: finished adding file data to be processed`);
      });
    },
    upload: uploadOptions => {
      processor.processPendingBatches(uploadOptions);
    },
    abort: id => {
      processor.abort(id);
    },
    abortBatch: id => {
      processor.abortBatch(id);
    },
    getOptions,
    clearPending,
    registerExtension: (name, methods) => {
      (0, _shared.invariant)(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);
      (0, _shared.invariant)(!extensions[name], EXT_ALREADY_EXISTS, name);
      _shared.logger.debugLog(`uploady.uploader: registering extension: ${name.toString()}`, methods);
      extensions[name] = methods;
    },
    getExtension: name => {
      return extensions[name];
    }
  }, EVENT_NAMES, {
    canAddEvents: false,
    canRemoveEvents: false
  });
  const triggerWithUnwrap = (name, ...data) => {
    const lp = (0, _lifeEvents.createLifePack)(() => data.map(_utils.deepProxyUnwrap));
    return trigger(name, lp);
  };
  const cancellable = (0, _shared.triggerCancellable)(triggerWithUnwrap);
  const enhancedUploader = getEnhancedUploader(uploader, uploaderOptions, triggerWithUnwrap, state => {
    enhancerTime = state;
  });
  const processor = (0, _processor.default)(triggerWithUnwrap, cancellable, uploaderOptions, enhancedUploader.id);
  return (0, _shared.devFreeze)(enhancedUploader);
};
var _default = exports.default = createUploader;